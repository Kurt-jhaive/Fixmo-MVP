
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ServiceProviderDetails
 * 
 */
export type ServiceProviderDetails = $Result.DefaultSelection<Prisma.$ServiceProviderDetailsPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model ServiceListing
 * 
 */
export type ServiceListing = $Result.DefaultSelection<Prisma.$ServiceListingPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model SpecificService
 * 
 */
export type SpecificService = $Result.DefaultSelection<Prisma.$SpecificServicePayload>
/**
 * Model CoveredService
 * 
 */
export type CoveredService = $Result.DefaultSelection<Prisma.$CoveredServicePayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model OTPVerification
 * 
 */
export type OTPVerification = $Result.DefaultSelection<Prisma.$OTPVerificationPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceProviderDetails`: Exposes CRUD operations for the **ServiceProviderDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceProviderDetails
    * const serviceProviderDetails = await prisma.serviceProviderDetails.findMany()
    * ```
    */
  get serviceProviderDetails(): Prisma.ServiceProviderDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceListing`: Exposes CRUD operations for the **ServiceListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceListings
    * const serviceListings = await prisma.serviceListing.findMany()
    * ```
    */
  get serviceListing(): Prisma.ServiceListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specificService`: Exposes CRUD operations for the **SpecificService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecificServices
    * const specificServices = await prisma.specificService.findMany()
    * ```
    */
  get specificService(): Prisma.SpecificServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coveredService`: Exposes CRUD operations for the **CoveredService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoveredServices
    * const coveredServices = await prisma.coveredService.findMany()
    * ```
    */
  get coveredService(): Prisma.CoveredServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTPVerification`: Exposes CRUD operations for the **OTPVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPVerifications
    * const oTPVerifications = await prisma.oTPVerification.findMany()
    * ```
    */
  get oTPVerification(): Prisma.OTPVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ServiceProviderDetails: 'ServiceProviderDetails',
    Certificate: 'Certificate',
    ServiceListing: 'ServiceListing',
    ServiceCategory: 'ServiceCategory',
    SpecificService: 'SpecificService',
    CoveredService: 'CoveredService',
    Availability: 'Availability',
    Appointment: 'Appointment',
    Rating: 'Rating',
    OTPVerification: 'OTPVerification',
    Admin: 'Admin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "serviceProviderDetails" | "certificate" | "serviceListing" | "serviceCategory" | "specificService" | "coveredService" | "availability" | "appointment" | "rating" | "oTPVerification" | "admin"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ServiceProviderDetails: {
        payload: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
        fields: Prisma.ServiceProviderDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceProviderDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceProviderDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          findFirst: {
            args: Prisma.ServiceProviderDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceProviderDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          findMany: {
            args: Prisma.ServiceProviderDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>[]
          }
          create: {
            args: Prisma.ServiceProviderDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          createMany: {
            args: Prisma.ServiceProviderDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceProviderDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>[]
          }
          delete: {
            args: Prisma.ServiceProviderDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          update: {
            args: Prisma.ServiceProviderDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          deleteMany: {
            args: Prisma.ServiceProviderDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceProviderDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceProviderDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>[]
          }
          upsert: {
            args: Prisma.ServiceProviderDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderDetailsPayload>
          }
          aggregate: {
            args: Prisma.ServiceProviderDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceProviderDetails>
          }
          groupBy: {
            args: Prisma.ServiceProviderDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceProviderDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderDetailsCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      ServiceListing: {
        payload: Prisma.$ServiceListingPayload<ExtArgs>
        fields: Prisma.ServiceListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          findFirst: {
            args: Prisma.ServiceListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          findMany: {
            args: Prisma.ServiceListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>[]
          }
          create: {
            args: Prisma.ServiceListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          createMany: {
            args: Prisma.ServiceListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>[]
          }
          delete: {
            args: Prisma.ServiceListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          update: {
            args: Prisma.ServiceListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>[]
          }
          upsert: {
            args: Prisma.ServiceListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceListingPayload>
          }
          aggregate: {
            args: Prisma.ServiceListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceListing>
          }
          groupBy: {
            args: Prisma.ServiceListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceListingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceListingCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      SpecificService: {
        payload: Prisma.$SpecificServicePayload<ExtArgs>
        fields: Prisma.SpecificServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecificServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecificServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          findFirst: {
            args: Prisma.SpecificServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecificServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          findMany: {
            args: Prisma.SpecificServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>[]
          }
          create: {
            args: Prisma.SpecificServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          createMany: {
            args: Prisma.SpecificServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecificServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>[]
          }
          delete: {
            args: Prisma.SpecificServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          update: {
            args: Prisma.SpecificServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          deleteMany: {
            args: Prisma.SpecificServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecificServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecificServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>[]
          }
          upsert: {
            args: Prisma.SpecificServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificServicePayload>
          }
          aggregate: {
            args: Prisma.SpecificServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecificService>
          }
          groupBy: {
            args: Prisma.SpecificServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecificServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecificServiceCountArgs<ExtArgs>
            result: $Utils.Optional<SpecificServiceCountAggregateOutputType> | number
          }
        }
      }
      CoveredService: {
        payload: Prisma.$CoveredServicePayload<ExtArgs>
        fields: Prisma.CoveredServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoveredServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoveredServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          findFirst: {
            args: Prisma.CoveredServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoveredServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          findMany: {
            args: Prisma.CoveredServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>[]
          }
          create: {
            args: Prisma.CoveredServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          createMany: {
            args: Prisma.CoveredServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoveredServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>[]
          }
          delete: {
            args: Prisma.CoveredServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          update: {
            args: Prisma.CoveredServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          deleteMany: {
            args: Prisma.CoveredServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoveredServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoveredServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>[]
          }
          upsert: {
            args: Prisma.CoveredServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoveredServicePayload>
          }
          aggregate: {
            args: Prisma.CoveredServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoveredService>
          }
          groupBy: {
            args: Prisma.CoveredServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoveredServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoveredServiceCountArgs<ExtArgs>
            result: $Utils.Optional<CoveredServiceCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      OTPVerification: {
        payload: Prisma.$OTPVerificationPayload<ExtArgs>
        fields: Prisma.OTPVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          findFirst: {
            args: Prisma.OTPVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          findMany: {
            args: Prisma.OTPVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>[]
          }
          create: {
            args: Prisma.OTPVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          createMany: {
            args: Prisma.OTPVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>[]
          }
          delete: {
            args: Prisma.OTPVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          update: {
            args: Prisma.OTPVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          deleteMany: {
            args: Prisma.OTPVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>[]
          }
          upsert: {
            args: Prisma.OTPVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPVerificationPayload>
          }
          aggregate: {
            args: Prisma.OTPVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTPVerification>
          }
          groupBy: {
            args: Prisma.OTPVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<OTPVerificationCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    serviceProviderDetails?: ServiceProviderDetailsOmit
    certificate?: CertificateOmit
    serviceListing?: ServiceListingOmit
    serviceCategory?: ServiceCategoryOmit
    specificService?: SpecificServiceOmit
    coveredService?: CoveredServiceOmit
    availability?: AvailabilityOmit
    appointment?: AppointmentOmit
    rating?: RatingOmit
    oTPVerification?: OTPVerificationOmit
    admin?: AdminOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    user_appointments: number
    user_rating: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_appointments?: boolean | UserCountOutputTypeCountUser_appointmentsArgs
    user_rating?: boolean | UserCountOutputTypeCountUser_ratingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type ServiceProviderDetailsCountOutputType
   */

  export type ServiceProviderDetailsCountOutputType = {
    provider_appointments: number
    provider_availability: number
    provider_certificates: number
    provider_ratings: number
    provider_services: number
  }

  export type ServiceProviderDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_appointments?: boolean | ServiceProviderDetailsCountOutputTypeCountProvider_appointmentsArgs
    provider_availability?: boolean | ServiceProviderDetailsCountOutputTypeCountProvider_availabilityArgs
    provider_certificates?: boolean | ServiceProviderDetailsCountOutputTypeCountProvider_certificatesArgs
    provider_ratings?: boolean | ServiceProviderDetailsCountOutputTypeCountProvider_ratingsArgs
    provider_services?: boolean | ServiceProviderDetailsCountOutputTypeCountProvider_servicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetailsCountOutputType
     */
    select?: ServiceProviderDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeCountProvider_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeCountProvider_availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeCountProvider_certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeCountProvider_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * ServiceProviderDetailsCountOutputType without action
   */
  export type ServiceProviderDetailsCountOutputTypeCountProvider_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceListingWhereInput
  }


  /**
   * Count Type CertificateCountOutputType
   */

  export type CertificateCountOutputType = {
    CoveredService: number
  }

  export type CertificateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CoveredService?: boolean | CertificateCountOutputTypeCountCoveredServiceArgs
  }

  // Custom InputTypes
  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateCountOutputType
     */
    select?: CertificateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeCountCoveredServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoveredServiceWhereInput
  }


  /**
   * Count Type ServiceListingCountOutputType
   */

  export type ServiceListingCountOutputType = {
    appointments: number
    specific_services: number
  }

  export type ServiceListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ServiceListingCountOutputTypeCountAppointmentsArgs
    specific_services?: boolean | ServiceListingCountOutputTypeCountSpecific_servicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceListingCountOutputType without action
   */
  export type ServiceListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListingCountOutputType
     */
    select?: ServiceListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceListingCountOutputType without action
   */
  export type ServiceListingCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ServiceListingCountOutputType without action
   */
  export type ServiceListingCountOutputTypeCountSpecific_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificServiceWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    specific_services: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specific_services?: boolean | ServiceCategoryCountOutputTypeCountSpecific_servicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountSpecific_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificServiceWhereInput
  }


  /**
   * Count Type SpecificServiceCountOutputType
   */

  export type SpecificServiceCountOutputType = {
    covered_by_certificates: number
  }

  export type SpecificServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    covered_by_certificates?: boolean | SpecificServiceCountOutputTypeCountCovered_by_certificatesArgs
  }

  // Custom InputTypes
  /**
   * SpecificServiceCountOutputType without action
   */
  export type SpecificServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificServiceCountOutputType
     */
    select?: SpecificServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecificServiceCountOutputType without action
   */
  export type SpecificServiceCountOutputTypeCountCovered_by_certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoveredServiceWhereInput
  }


  /**
   * Count Type AvailabilityCountOutputType
   */

  export type AvailabilityCountOutputType = {
    appointments: number
  }

  export type AvailabilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | AvailabilityCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * AvailabilityCountOutputType without action
   */
  export type AvailabilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityCountOutputType
     */
    select?: AvailabilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AvailabilityCountOutputType without action
   */
  export type AvailabilityCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    appointment_rating: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment_rating?: boolean | AppointmentCountOutputTypeCountAppointment_ratingArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountAppointment_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    profile_photo: string | null
    valid_id: string | null
    user_location: string | null
    created_at: Date | null
    is_verified: boolean | null
    password: string | null
    userName: string | null
    is_activated: boolean | null
    birthday: Date | null
    exact_location: string | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    profile_photo: string | null
    valid_id: string | null
    user_location: string | null
    created_at: Date | null
    is_verified: boolean | null
    password: string | null
    userName: string | null
    is_activated: boolean | null
    birthday: Date | null
    exact_location: string | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    first_name: number
    last_name: number
    email: number
    phone_number: number
    profile_photo: number
    valid_id: number
    user_location: number
    created_at: number
    is_verified: number
    password: number
    userName: number
    is_activated: number
    birthday: number
    exact_location: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    profile_photo?: true
    valid_id?: true
    user_location?: true
    created_at?: true
    is_verified?: true
    password?: true
    userName?: true
    is_activated?: true
    birthday?: true
    exact_location?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    profile_photo?: true
    valid_id?: true
    user_location?: true
    created_at?: true
    is_verified?: true
    password?: true
    userName?: true
    is_activated?: true
    birthday?: true
    exact_location?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    profile_photo?: true
    valid_id?: true
    user_location?: true
    created_at?: true
    is_verified?: true
    password?: true
    userName?: true
    is_activated?: true
    birthday?: true
    exact_location?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo: string | null
    valid_id: string | null
    user_location: string | null
    created_at: Date
    is_verified: boolean
    password: string
    userName: string
    is_activated: boolean
    birthday: Date | null
    exact_location: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    profile_photo?: boolean
    valid_id?: boolean
    user_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    password?: boolean
    userName?: boolean
    is_activated?: boolean
    birthday?: boolean
    exact_location?: boolean
    user_appointments?: boolean | User$user_appointmentsArgs<ExtArgs>
    user_rating?: boolean | User$user_ratingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    profile_photo?: boolean
    valid_id?: boolean
    user_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    password?: boolean
    userName?: boolean
    is_activated?: boolean
    birthday?: boolean
    exact_location?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    profile_photo?: boolean
    valid_id?: boolean
    user_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    password?: boolean
    userName?: boolean
    is_activated?: boolean
    birthday?: boolean
    exact_location?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    profile_photo?: boolean
    valid_id?: boolean
    user_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    password?: boolean
    userName?: boolean
    is_activated?: boolean
    birthday?: boolean
    exact_location?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "first_name" | "last_name" | "email" | "phone_number" | "profile_photo" | "valid_id" | "user_location" | "created_at" | "is_verified" | "password" | "userName" | "is_activated" | "birthday" | "exact_location", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_appointments?: boolean | User$user_appointmentsArgs<ExtArgs>
    user_rating?: boolean | User$user_ratingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      user_appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      user_rating: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      first_name: string
      last_name: string
      email: string
      phone_number: string
      profile_photo: string | null
      valid_id: string | null
      user_location: string | null
      created_at: Date
      is_verified: boolean
      password: string
      userName: string
      is_activated: boolean
      birthday: Date | null
      exact_location: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_appointments<T extends User$user_appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$user_appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_rating<T extends User$user_ratingArgs<ExtArgs> = {}>(args?: Subset<T, User$user_ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly user_id: FieldRef<"User", 'Int'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly profile_photo: FieldRef<"User", 'String'>
    readonly valid_id: FieldRef<"User", 'String'>
    readonly user_location: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly is_verified: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly is_activated: FieldRef<"User", 'Boolean'>
    readonly birthday: FieldRef<"User", 'DateTime'>
    readonly exact_location: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.user_appointments
   */
  export type User$user_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.user_rating
   */
  export type User$user_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ServiceProviderDetails
   */

  export type AggregateServiceProviderDetails = {
    _count: ServiceProviderDetailsCountAggregateOutputType | null
    _avg: ServiceProviderDetailsAvgAggregateOutputType | null
    _sum: ServiceProviderDetailsSumAggregateOutputType | null
    _min: ServiceProviderDetailsMinAggregateOutputType | null
    _max: ServiceProviderDetailsMaxAggregateOutputType | null
  }

  export type ServiceProviderDetailsAvgAggregateOutputType = {
    provider_id: number | null
    provider_rating: number | null
  }

  export type ServiceProviderDetailsSumAggregateOutputType = {
    provider_id: number | null
    provider_rating: number | null
  }

  export type ServiceProviderDetailsMinAggregateOutputType = {
    provider_id: number | null
    provider_first_name: string | null
    provider_last_name: string | null
    provider_email: string | null
    provider_phone_number: string | null
    provider_profile_photo: string | null
    provider_valid_id: string | null
    provider_isVerified: boolean | null
    created_at: Date | null
    provider_rating: number | null
    provider_location: string | null
    provider_uli: string | null
    provider_password: string | null
    provider_userName: string | null
    provider_isActivated: boolean | null
    provider_birthday: Date | null
    provider_exact_location: string | null
  }

  export type ServiceProviderDetailsMaxAggregateOutputType = {
    provider_id: number | null
    provider_first_name: string | null
    provider_last_name: string | null
    provider_email: string | null
    provider_phone_number: string | null
    provider_profile_photo: string | null
    provider_valid_id: string | null
    provider_isVerified: boolean | null
    created_at: Date | null
    provider_rating: number | null
    provider_location: string | null
    provider_uli: string | null
    provider_password: string | null
    provider_userName: string | null
    provider_isActivated: boolean | null
    provider_birthday: Date | null
    provider_exact_location: string | null
  }

  export type ServiceProviderDetailsCountAggregateOutputType = {
    provider_id: number
    provider_first_name: number
    provider_last_name: number
    provider_email: number
    provider_phone_number: number
    provider_profile_photo: number
    provider_valid_id: number
    provider_isVerified: number
    created_at: number
    provider_rating: number
    provider_location: number
    provider_uli: number
    provider_password: number
    provider_userName: number
    provider_isActivated: number
    provider_birthday: number
    provider_exact_location: number
    _all: number
  }


  export type ServiceProviderDetailsAvgAggregateInputType = {
    provider_id?: true
    provider_rating?: true
  }

  export type ServiceProviderDetailsSumAggregateInputType = {
    provider_id?: true
    provider_rating?: true
  }

  export type ServiceProviderDetailsMinAggregateInputType = {
    provider_id?: true
    provider_first_name?: true
    provider_last_name?: true
    provider_email?: true
    provider_phone_number?: true
    provider_profile_photo?: true
    provider_valid_id?: true
    provider_isVerified?: true
    created_at?: true
    provider_rating?: true
    provider_location?: true
    provider_uli?: true
    provider_password?: true
    provider_userName?: true
    provider_isActivated?: true
    provider_birthday?: true
    provider_exact_location?: true
  }

  export type ServiceProviderDetailsMaxAggregateInputType = {
    provider_id?: true
    provider_first_name?: true
    provider_last_name?: true
    provider_email?: true
    provider_phone_number?: true
    provider_profile_photo?: true
    provider_valid_id?: true
    provider_isVerified?: true
    created_at?: true
    provider_rating?: true
    provider_location?: true
    provider_uli?: true
    provider_password?: true
    provider_userName?: true
    provider_isActivated?: true
    provider_birthday?: true
    provider_exact_location?: true
  }

  export type ServiceProviderDetailsCountAggregateInputType = {
    provider_id?: true
    provider_first_name?: true
    provider_last_name?: true
    provider_email?: true
    provider_phone_number?: true
    provider_profile_photo?: true
    provider_valid_id?: true
    provider_isVerified?: true
    created_at?: true
    provider_rating?: true
    provider_location?: true
    provider_uli?: true
    provider_password?: true
    provider_userName?: true
    provider_isActivated?: true
    provider_birthday?: true
    provider_exact_location?: true
    _all?: true
  }

  export type ServiceProviderDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProviderDetails to aggregate.
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviderDetails to fetch.
     */
    orderBy?: ServiceProviderDetailsOrderByWithRelationInput | ServiceProviderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceProviderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceProviderDetails
    **/
    _count?: true | ServiceProviderDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceProviderDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceProviderDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceProviderDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceProviderDetailsMaxAggregateInputType
  }

  export type GetServiceProviderDetailsAggregateType<T extends ServiceProviderDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceProviderDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceProviderDetails[P]>
      : GetScalarType<T[P], AggregateServiceProviderDetails[P]>
  }




  export type ServiceProviderDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderDetailsWhereInput
    orderBy?: ServiceProviderDetailsOrderByWithAggregationInput | ServiceProviderDetailsOrderByWithAggregationInput[]
    by: ServiceProviderDetailsScalarFieldEnum[] | ServiceProviderDetailsScalarFieldEnum
    having?: ServiceProviderDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceProviderDetailsCountAggregateInputType | true
    _avg?: ServiceProviderDetailsAvgAggregateInputType
    _sum?: ServiceProviderDetailsSumAggregateInputType
    _min?: ServiceProviderDetailsMinAggregateInputType
    _max?: ServiceProviderDetailsMaxAggregateInputType
  }

  export type ServiceProviderDetailsGroupByOutputType = {
    provider_id: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo: string | null
    provider_valid_id: string | null
    provider_isVerified: boolean
    created_at: Date
    provider_rating: number
    provider_location: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated: boolean
    provider_birthday: Date | null
    provider_exact_location: string | null
    _count: ServiceProviderDetailsCountAggregateOutputType | null
    _avg: ServiceProviderDetailsAvgAggregateOutputType | null
    _sum: ServiceProviderDetailsSumAggregateOutputType | null
    _min: ServiceProviderDetailsMinAggregateOutputType | null
    _max: ServiceProviderDetailsMaxAggregateOutputType | null
  }

  type GetServiceProviderDetailsGroupByPayload<T extends ServiceProviderDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceProviderDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceProviderDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceProviderDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceProviderDetailsGroupByOutputType[P]>
        }
      >
    >


  export type ServiceProviderDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_first_name?: boolean
    provider_last_name?: boolean
    provider_email?: boolean
    provider_phone_number?: boolean
    provider_profile_photo?: boolean
    provider_valid_id?: boolean
    provider_isVerified?: boolean
    created_at?: boolean
    provider_rating?: boolean
    provider_location?: boolean
    provider_uli?: boolean
    provider_password?: boolean
    provider_userName?: boolean
    provider_isActivated?: boolean
    provider_birthday?: boolean
    provider_exact_location?: boolean
    provider_appointments?: boolean | ServiceProviderDetails$provider_appointmentsArgs<ExtArgs>
    provider_availability?: boolean | ServiceProviderDetails$provider_availabilityArgs<ExtArgs>
    provider_certificates?: boolean | ServiceProviderDetails$provider_certificatesArgs<ExtArgs>
    provider_ratings?: boolean | ServiceProviderDetails$provider_ratingsArgs<ExtArgs>
    provider_services?: boolean | ServiceProviderDetails$provider_servicesArgs<ExtArgs>
    _count?: boolean | ServiceProviderDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProviderDetails"]>

  export type ServiceProviderDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_first_name?: boolean
    provider_last_name?: boolean
    provider_email?: boolean
    provider_phone_number?: boolean
    provider_profile_photo?: boolean
    provider_valid_id?: boolean
    provider_isVerified?: boolean
    created_at?: boolean
    provider_rating?: boolean
    provider_location?: boolean
    provider_uli?: boolean
    provider_password?: boolean
    provider_userName?: boolean
    provider_isActivated?: boolean
    provider_birthday?: boolean
    provider_exact_location?: boolean
  }, ExtArgs["result"]["serviceProviderDetails"]>

  export type ServiceProviderDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_first_name?: boolean
    provider_last_name?: boolean
    provider_email?: boolean
    provider_phone_number?: boolean
    provider_profile_photo?: boolean
    provider_valid_id?: boolean
    provider_isVerified?: boolean
    created_at?: boolean
    provider_rating?: boolean
    provider_location?: boolean
    provider_uli?: boolean
    provider_password?: boolean
    provider_userName?: boolean
    provider_isActivated?: boolean
    provider_birthday?: boolean
    provider_exact_location?: boolean
  }, ExtArgs["result"]["serviceProviderDetails"]>

  export type ServiceProviderDetailsSelectScalar = {
    provider_id?: boolean
    provider_first_name?: boolean
    provider_last_name?: boolean
    provider_email?: boolean
    provider_phone_number?: boolean
    provider_profile_photo?: boolean
    provider_valid_id?: boolean
    provider_isVerified?: boolean
    created_at?: boolean
    provider_rating?: boolean
    provider_location?: boolean
    provider_uli?: boolean
    provider_password?: boolean
    provider_userName?: boolean
    provider_isActivated?: boolean
    provider_birthday?: boolean
    provider_exact_location?: boolean
  }

  export type ServiceProviderDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"provider_id" | "provider_first_name" | "provider_last_name" | "provider_email" | "provider_phone_number" | "provider_profile_photo" | "provider_valid_id" | "provider_isVerified" | "created_at" | "provider_rating" | "provider_location" | "provider_uli" | "provider_password" | "provider_userName" | "provider_isActivated" | "provider_birthday" | "provider_exact_location", ExtArgs["result"]["serviceProviderDetails"]>
  export type ServiceProviderDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_appointments?: boolean | ServiceProviderDetails$provider_appointmentsArgs<ExtArgs>
    provider_availability?: boolean | ServiceProviderDetails$provider_availabilityArgs<ExtArgs>
    provider_certificates?: boolean | ServiceProviderDetails$provider_certificatesArgs<ExtArgs>
    provider_ratings?: boolean | ServiceProviderDetails$provider_ratingsArgs<ExtArgs>
    provider_services?: boolean | ServiceProviderDetails$provider_servicesArgs<ExtArgs>
    _count?: boolean | ServiceProviderDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceProviderDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceProviderDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceProviderDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceProviderDetails"
    objects: {
      provider_appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      provider_availability: Prisma.$AvailabilityPayload<ExtArgs>[]
      provider_certificates: Prisma.$CertificatePayload<ExtArgs>[]
      provider_ratings: Prisma.$RatingPayload<ExtArgs>[]
      provider_services: Prisma.$ServiceListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      provider_id: number
      provider_first_name: string
      provider_last_name: string
      provider_email: string
      provider_phone_number: string
      provider_profile_photo: string | null
      provider_valid_id: string | null
      provider_isVerified: boolean
      created_at: Date
      provider_rating: number
      provider_location: string | null
      provider_uli: string
      provider_password: string
      provider_userName: string
      provider_isActivated: boolean
      provider_birthday: Date | null
      provider_exact_location: string | null
    }, ExtArgs["result"]["serviceProviderDetails"]>
    composites: {}
  }

  type ServiceProviderDetailsGetPayload<S extends boolean | null | undefined | ServiceProviderDetailsDefaultArgs> = $Result.GetResult<Prisma.$ServiceProviderDetailsPayload, S>

  type ServiceProviderDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceProviderDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceProviderDetailsCountAggregateInputType | true
    }

  export interface ServiceProviderDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceProviderDetails'], meta: { name: 'ServiceProviderDetails' } }
    /**
     * Find zero or one ServiceProviderDetails that matches the filter.
     * @param {ServiceProviderDetailsFindUniqueArgs} args - Arguments to find a ServiceProviderDetails
     * @example
     * // Get one ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProviderDetailsFindUniqueArgs>(args: SelectSubset<T, ServiceProviderDetailsFindUniqueArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceProviderDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceProviderDetailsFindUniqueOrThrowArgs} args - Arguments to find a ServiceProviderDetails
     * @example
     * // Get one ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProviderDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceProviderDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProviderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsFindFirstArgs} args - Arguments to find a ServiceProviderDetails
     * @example
     * // Get one ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProviderDetailsFindFirstArgs>(args?: SelectSubset<T, ServiceProviderDetailsFindFirstArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProviderDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsFindFirstOrThrowArgs} args - Arguments to find a ServiceProviderDetails
     * @example
     * // Get one ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProviderDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceProviderDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProviderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findMany()
     * 
     * // Get first 10 ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.findMany({ take: 10 })
     * 
     * // Only select the `provider_id`
     * const serviceProviderDetailsWithProvider_idOnly = await prisma.serviceProviderDetails.findMany({ select: { provider_id: true } })
     * 
     */
    findMany<T extends ServiceProviderDetailsFindManyArgs>(args?: SelectSubset<T, ServiceProviderDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceProviderDetails.
     * @param {ServiceProviderDetailsCreateArgs} args - Arguments to create a ServiceProviderDetails.
     * @example
     * // Create one ServiceProviderDetails
     * const ServiceProviderDetails = await prisma.serviceProviderDetails.create({
     *   data: {
     *     // ... data to create a ServiceProviderDetails
     *   }
     * })
     * 
     */
    create<T extends ServiceProviderDetailsCreateArgs>(args: SelectSubset<T, ServiceProviderDetailsCreateArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceProviderDetails.
     * @param {ServiceProviderDetailsCreateManyArgs} args - Arguments to create many ServiceProviderDetails.
     * @example
     * // Create many ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceProviderDetailsCreateManyArgs>(args?: SelectSubset<T, ServiceProviderDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceProviderDetails and returns the data saved in the database.
     * @param {ServiceProviderDetailsCreateManyAndReturnArgs} args - Arguments to create many ServiceProviderDetails.
     * @example
     * // Create many ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceProviderDetails and only return the `provider_id`
     * const serviceProviderDetailsWithProvider_idOnly = await prisma.serviceProviderDetails.createManyAndReturn({
     *   select: { provider_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceProviderDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceProviderDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceProviderDetails.
     * @param {ServiceProviderDetailsDeleteArgs} args - Arguments to delete one ServiceProviderDetails.
     * @example
     * // Delete one ServiceProviderDetails
     * const ServiceProviderDetails = await prisma.serviceProviderDetails.delete({
     *   where: {
     *     // ... filter to delete one ServiceProviderDetails
     *   }
     * })
     * 
     */
    delete<T extends ServiceProviderDetailsDeleteArgs>(args: SelectSubset<T, ServiceProviderDetailsDeleteArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceProviderDetails.
     * @param {ServiceProviderDetailsUpdateArgs} args - Arguments to update one ServiceProviderDetails.
     * @example
     * // Update one ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceProviderDetailsUpdateArgs>(args: SelectSubset<T, ServiceProviderDetailsUpdateArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceProviderDetails.
     * @param {ServiceProviderDetailsDeleteManyArgs} args - Arguments to filter ServiceProviderDetails to delete.
     * @example
     * // Delete a few ServiceProviderDetails
     * const { count } = await prisma.serviceProviderDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceProviderDetailsDeleteManyArgs>(args?: SelectSubset<T, ServiceProviderDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceProviderDetailsUpdateManyArgs>(args: SelectSubset<T, ServiceProviderDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviderDetails and returns the data updated in the database.
     * @param {ServiceProviderDetailsUpdateManyAndReturnArgs} args - Arguments to update many ServiceProviderDetails.
     * @example
     * // Update many ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceProviderDetails and only return the `provider_id`
     * const serviceProviderDetailsWithProvider_idOnly = await prisma.serviceProviderDetails.updateManyAndReturn({
     *   select: { provider_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceProviderDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceProviderDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceProviderDetails.
     * @param {ServiceProviderDetailsUpsertArgs} args - Arguments to update or create a ServiceProviderDetails.
     * @example
     * // Update or create a ServiceProviderDetails
     * const serviceProviderDetails = await prisma.serviceProviderDetails.upsert({
     *   create: {
     *     // ... data to create a ServiceProviderDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProviderDetails we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProviderDetailsUpsertArgs>(args: SelectSubset<T, ServiceProviderDetailsUpsertArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceProviderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsCountArgs} args - Arguments to filter ServiceProviderDetails to count.
     * @example
     * // Count the number of ServiceProviderDetails
     * const count = await prisma.serviceProviderDetails.count({
     *   where: {
     *     // ... the filter for the ServiceProviderDetails we want to count
     *   }
     * })
    **/
    count<T extends ServiceProviderDetailsCountArgs>(
      args?: Subset<T, ServiceProviderDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceProviderDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceProviderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceProviderDetailsAggregateArgs>(args: Subset<T, ServiceProviderDetailsAggregateArgs>): Prisma.PrismaPromise<GetServiceProviderDetailsAggregateType<T>>

    /**
     * Group by ServiceProviderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceProviderDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceProviderDetailsGroupByArgs['orderBy'] }
        : { orderBy?: ServiceProviderDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceProviderDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceProviderDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceProviderDetails model
   */
  readonly fields: ServiceProviderDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceProviderDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceProviderDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_appointments<T extends ServiceProviderDetails$provider_appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetails$provider_appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_availability<T extends ServiceProviderDetails$provider_availabilityArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetails$provider_availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_certificates<T extends ServiceProviderDetails$provider_certificatesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetails$provider_certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_ratings<T extends ServiceProviderDetails$provider_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetails$provider_ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_services<T extends ServiceProviderDetails$provider_servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetails$provider_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceProviderDetails model
   */
  interface ServiceProviderDetailsFieldRefs {
    readonly provider_id: FieldRef<"ServiceProviderDetails", 'Int'>
    readonly provider_first_name: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_last_name: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_email: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_phone_number: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_profile_photo: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_valid_id: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_isVerified: FieldRef<"ServiceProviderDetails", 'Boolean'>
    readonly created_at: FieldRef<"ServiceProviderDetails", 'DateTime'>
    readonly provider_rating: FieldRef<"ServiceProviderDetails", 'Float'>
    readonly provider_location: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_uli: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_password: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_userName: FieldRef<"ServiceProviderDetails", 'String'>
    readonly provider_isActivated: FieldRef<"ServiceProviderDetails", 'Boolean'>
    readonly provider_birthday: FieldRef<"ServiceProviderDetails", 'DateTime'>
    readonly provider_exact_location: FieldRef<"ServiceProviderDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceProviderDetails findUnique
   */
  export type ServiceProviderDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviderDetails to fetch.
     */
    where: ServiceProviderDetailsWhereUniqueInput
  }

  /**
   * ServiceProviderDetails findUniqueOrThrow
   */
  export type ServiceProviderDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviderDetails to fetch.
     */
    where: ServiceProviderDetailsWhereUniqueInput
  }

  /**
   * ServiceProviderDetails findFirst
   */
  export type ServiceProviderDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviderDetails to fetch.
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviderDetails to fetch.
     */
    orderBy?: ServiceProviderDetailsOrderByWithRelationInput | ServiceProviderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviderDetails.
     */
    cursor?: ServiceProviderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviderDetails.
     */
    distinct?: ServiceProviderDetailsScalarFieldEnum | ServiceProviderDetailsScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails findFirstOrThrow
   */
  export type ServiceProviderDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviderDetails to fetch.
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviderDetails to fetch.
     */
    orderBy?: ServiceProviderDetailsOrderByWithRelationInput | ServiceProviderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviderDetails.
     */
    cursor?: ServiceProviderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviderDetails.
     */
    distinct?: ServiceProviderDetailsScalarFieldEnum | ServiceProviderDetailsScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails findMany
   */
  export type ServiceProviderDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviderDetails to fetch.
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviderDetails to fetch.
     */
    orderBy?: ServiceProviderDetailsOrderByWithRelationInput | ServiceProviderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceProviderDetails.
     */
    cursor?: ServiceProviderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviderDetails.
     */
    skip?: number
    distinct?: ServiceProviderDetailsScalarFieldEnum | ServiceProviderDetailsScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails create
   */
  export type ServiceProviderDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceProviderDetails.
     */
    data: XOR<ServiceProviderDetailsCreateInput, ServiceProviderDetailsUncheckedCreateInput>
  }

  /**
   * ServiceProviderDetails createMany
   */
  export type ServiceProviderDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceProviderDetails.
     */
    data: ServiceProviderDetailsCreateManyInput | ServiceProviderDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceProviderDetails createManyAndReturn
   */
  export type ServiceProviderDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceProviderDetails.
     */
    data: ServiceProviderDetailsCreateManyInput | ServiceProviderDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceProviderDetails update
   */
  export type ServiceProviderDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceProviderDetails.
     */
    data: XOR<ServiceProviderDetailsUpdateInput, ServiceProviderDetailsUncheckedUpdateInput>
    /**
     * Choose, which ServiceProviderDetails to update.
     */
    where: ServiceProviderDetailsWhereUniqueInput
  }

  /**
   * ServiceProviderDetails updateMany
   */
  export type ServiceProviderDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceProviderDetails.
     */
    data: XOR<ServiceProviderDetailsUpdateManyMutationInput, ServiceProviderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviderDetails to update
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * Limit how many ServiceProviderDetails to update.
     */
    limit?: number
  }

  /**
   * ServiceProviderDetails updateManyAndReturn
   */
  export type ServiceProviderDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * The data used to update ServiceProviderDetails.
     */
    data: XOR<ServiceProviderDetailsUpdateManyMutationInput, ServiceProviderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviderDetails to update
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * Limit how many ServiceProviderDetails to update.
     */
    limit?: number
  }

  /**
   * ServiceProviderDetails upsert
   */
  export type ServiceProviderDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceProviderDetails to update in case it exists.
     */
    where: ServiceProviderDetailsWhereUniqueInput
    /**
     * In case the ServiceProviderDetails found by the `where` argument doesn't exist, create a new ServiceProviderDetails with this data.
     */
    create: XOR<ServiceProviderDetailsCreateInput, ServiceProviderDetailsUncheckedCreateInput>
    /**
     * In case the ServiceProviderDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceProviderDetailsUpdateInput, ServiceProviderDetailsUncheckedUpdateInput>
  }

  /**
   * ServiceProviderDetails delete
   */
  export type ServiceProviderDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
    /**
     * Filter which ServiceProviderDetails to delete.
     */
    where: ServiceProviderDetailsWhereUniqueInput
  }

  /**
   * ServiceProviderDetails deleteMany
   */
  export type ServiceProviderDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProviderDetails to delete
     */
    where?: ServiceProviderDetailsWhereInput
    /**
     * Limit how many ServiceProviderDetails to delete.
     */
    limit?: number
  }

  /**
   * ServiceProviderDetails.provider_appointments
   */
  export type ServiceProviderDetails$provider_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails.provider_availability
   */
  export type ServiceProviderDetails$provider_availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails.provider_certificates
   */
  export type ServiceProviderDetails$provider_certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails.provider_ratings
   */
  export type ServiceProviderDetails$provider_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails.provider_services
   */
  export type ServiceProviderDetails$provider_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    where?: ServiceListingWhereInput
    orderBy?: ServiceListingOrderByWithRelationInput | ServiceListingOrderByWithRelationInput[]
    cursor?: ServiceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceListingScalarFieldEnum | ServiceListingScalarFieldEnum[]
  }

  /**
   * ServiceProviderDetails without action
   */
  export type ServiceProviderDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderDetails
     */
    select?: ServiceProviderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProviderDetails
     */
    omit?: ServiceProviderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    certificate_id: number | null
    provider_id: number | null
  }

  export type CertificateSumAggregateOutputType = {
    certificate_id: number | null
    provider_id: number | null
  }

  export type CertificateMinAggregateOutputType = {
    certificate_id: number | null
    certificate_name: string | null
    certificate_file_path: string | null
    expiry_date: Date | null
    provider_id: number | null
    certificate_number: string | null
    certificate_status: string | null
    created_at: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    certificate_id: number | null
    certificate_name: string | null
    certificate_file_path: string | null
    expiry_date: Date | null
    provider_id: number | null
    certificate_number: string | null
    certificate_status: string | null
    created_at: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    certificate_id: number
    certificate_name: number
    certificate_file_path: number
    expiry_date: number
    provider_id: number
    certificate_number: number
    certificate_status: number
    created_at: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    certificate_id?: true
    provider_id?: true
  }

  export type CertificateSumAggregateInputType = {
    certificate_id?: true
    provider_id?: true
  }

  export type CertificateMinAggregateInputType = {
    certificate_id?: true
    certificate_name?: true
    certificate_file_path?: true
    expiry_date?: true
    provider_id?: true
    certificate_number?: true
    certificate_status?: true
    created_at?: true
  }

  export type CertificateMaxAggregateInputType = {
    certificate_id?: true
    certificate_name?: true
    certificate_file_path?: true
    expiry_date?: true
    provider_id?: true
    certificate_number?: true
    certificate_status?: true
    created_at?: true
  }

  export type CertificateCountAggregateInputType = {
    certificate_id?: true
    certificate_name?: true
    certificate_file_path?: true
    expiry_date?: true
    provider_id?: true
    certificate_number?: true
    certificate_status?: true
    created_at?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    certificate_id: number
    certificate_name: string
    certificate_file_path: string
    expiry_date: Date | null
    provider_id: number
    certificate_number: string
    certificate_status: string
    created_at: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    certificate_id?: boolean
    certificate_name?: boolean
    certificate_file_path?: boolean
    expiry_date?: boolean
    provider_id?: boolean
    certificate_number?: boolean
    certificate_status?: boolean
    created_at?: boolean
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    CoveredService?: boolean | Certificate$CoveredServiceArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    certificate_id?: boolean
    certificate_name?: boolean
    certificate_file_path?: boolean
    expiry_date?: boolean
    provider_id?: boolean
    certificate_number?: boolean
    certificate_status?: boolean
    created_at?: boolean
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    certificate_id?: boolean
    certificate_name?: boolean
    certificate_file_path?: boolean
    expiry_date?: boolean
    provider_id?: boolean
    certificate_number?: boolean
    certificate_status?: boolean
    created_at?: boolean
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    certificate_id?: boolean
    certificate_name?: boolean
    certificate_file_path?: boolean
    expiry_date?: boolean
    provider_id?: boolean
    certificate_number?: boolean
    certificate_status?: boolean
    created_at?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"certificate_id" | "certificate_name" | "certificate_file_path" | "expiry_date" | "provider_id" | "certificate_number" | "certificate_status" | "created_at", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    CoveredService?: boolean | Certificate$CoveredServiceArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      provider: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
      CoveredService: Prisma.$CoveredServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      certificate_id: number
      certificate_name: string
      certificate_file_path: string
      expiry_date: Date | null
      provider_id: number
      certificate_number: string
      certificate_status: string
      created_at: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `certificate_id`
     * const certificateWithCertificate_idOnly = await prisma.certificate.findMany({ select: { certificate_id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `certificate_id`
     * const certificateWithCertificate_idOnly = await prisma.certificate.createManyAndReturn({
     *   select: { certificate_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `certificate_id`
     * const certificateWithCertificate_idOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { certificate_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ServiceProviderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetailsDefaultArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CoveredService<T extends Certificate$CoveredServiceArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$CoveredServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly certificate_id: FieldRef<"Certificate", 'Int'>
    readonly certificate_name: FieldRef<"Certificate", 'String'>
    readonly certificate_file_path: FieldRef<"Certificate", 'String'>
    readonly expiry_date: FieldRef<"Certificate", 'DateTime'>
    readonly provider_id: FieldRef<"Certificate", 'Int'>
    readonly certificate_number: FieldRef<"Certificate", 'String'>
    readonly certificate_status: FieldRef<"Certificate", 'String'>
    readonly created_at: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate.CoveredService
   */
  export type Certificate$CoveredServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    where?: CoveredServiceWhereInput
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    cursor?: CoveredServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoveredServiceScalarFieldEnum | CoveredServiceScalarFieldEnum[]
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model ServiceListing
   */

  export type AggregateServiceListing = {
    _count: ServiceListingCountAggregateOutputType | null
    _avg: ServiceListingAvgAggregateOutputType | null
    _sum: ServiceListingSumAggregateOutputType | null
    _min: ServiceListingMinAggregateOutputType | null
    _max: ServiceListingMaxAggregateOutputType | null
  }

  export type ServiceListingAvgAggregateOutputType = {
    service_id: number | null
    service_startingprice: number | null
    provider_id: number | null
  }

  export type ServiceListingSumAggregateOutputType = {
    service_id: number | null
    service_startingprice: number | null
    provider_id: number | null
  }

  export type ServiceListingMinAggregateOutputType = {
    service_id: number | null
    service_title: string | null
    service_description: string | null
    service_startingprice: number | null
    provider_id: number | null
    servicelisting_isActive: boolean | null
    service_picture: string | null
  }

  export type ServiceListingMaxAggregateOutputType = {
    service_id: number | null
    service_title: string | null
    service_description: string | null
    service_startingprice: number | null
    provider_id: number | null
    servicelisting_isActive: boolean | null
    service_picture: string | null
  }

  export type ServiceListingCountAggregateOutputType = {
    service_id: number
    service_title: number
    service_description: number
    service_startingprice: number
    provider_id: number
    servicelisting_isActive: number
    service_picture: number
    _all: number
  }


  export type ServiceListingAvgAggregateInputType = {
    service_id?: true
    service_startingprice?: true
    provider_id?: true
  }

  export type ServiceListingSumAggregateInputType = {
    service_id?: true
    service_startingprice?: true
    provider_id?: true
  }

  export type ServiceListingMinAggregateInputType = {
    service_id?: true
    service_title?: true
    service_description?: true
    service_startingprice?: true
    provider_id?: true
    servicelisting_isActive?: true
    service_picture?: true
  }

  export type ServiceListingMaxAggregateInputType = {
    service_id?: true
    service_title?: true
    service_description?: true
    service_startingprice?: true
    provider_id?: true
    servicelisting_isActive?: true
    service_picture?: true
  }

  export type ServiceListingCountAggregateInputType = {
    service_id?: true
    service_title?: true
    service_description?: true
    service_startingprice?: true
    provider_id?: true
    servicelisting_isActive?: true
    service_picture?: true
    _all?: true
  }

  export type ServiceListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceListing to aggregate.
     */
    where?: ServiceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceListings to fetch.
     */
    orderBy?: ServiceListingOrderByWithRelationInput | ServiceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceListings
    **/
    _count?: true | ServiceListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceListingMaxAggregateInputType
  }

  export type GetServiceListingAggregateType<T extends ServiceListingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceListing[P]>
      : GetScalarType<T[P], AggregateServiceListing[P]>
  }




  export type ServiceListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceListingWhereInput
    orderBy?: ServiceListingOrderByWithAggregationInput | ServiceListingOrderByWithAggregationInput[]
    by: ServiceListingScalarFieldEnum[] | ServiceListingScalarFieldEnum
    having?: ServiceListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceListingCountAggregateInputType | true
    _avg?: ServiceListingAvgAggregateInputType
    _sum?: ServiceListingSumAggregateInputType
    _min?: ServiceListingMinAggregateInputType
    _max?: ServiceListingMaxAggregateInputType
  }

  export type ServiceListingGroupByOutputType = {
    service_id: number
    service_title: string
    service_description: string
    service_startingprice: number
    provider_id: number
    servicelisting_isActive: boolean
    service_picture: string | null
    _count: ServiceListingCountAggregateOutputType | null
    _avg: ServiceListingAvgAggregateOutputType | null
    _sum: ServiceListingSumAggregateOutputType | null
    _min: ServiceListingMinAggregateOutputType | null
    _max: ServiceListingMaxAggregateOutputType | null
  }

  type GetServiceListingGroupByPayload<T extends ServiceListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceListingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceListingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    service_id?: boolean
    service_title?: boolean
    service_description?: boolean
    service_startingprice?: boolean
    provider_id?: boolean
    servicelisting_isActive?: boolean
    service_picture?: boolean
    appointments?: boolean | ServiceListing$appointmentsArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    specific_services?: boolean | ServiceListing$specific_servicesArgs<ExtArgs>
    _count?: boolean | ServiceListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceListing"]>

  export type ServiceListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    service_id?: boolean
    service_title?: boolean
    service_description?: boolean
    service_startingprice?: boolean
    provider_id?: boolean
    servicelisting_isActive?: boolean
    service_picture?: boolean
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceListing"]>

  export type ServiceListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    service_id?: boolean
    service_title?: boolean
    service_description?: boolean
    service_startingprice?: boolean
    provider_id?: boolean
    servicelisting_isActive?: boolean
    service_picture?: boolean
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceListing"]>

  export type ServiceListingSelectScalar = {
    service_id?: boolean
    service_title?: boolean
    service_description?: boolean
    service_startingprice?: boolean
    provider_id?: boolean
    servicelisting_isActive?: boolean
    service_picture?: boolean
  }

  export type ServiceListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"service_id" | "service_title" | "service_description" | "service_startingprice" | "provider_id" | "servicelisting_isActive" | "service_picture", ExtArgs["result"]["serviceListing"]>
  export type ServiceListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ServiceListing$appointmentsArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    specific_services?: boolean | ServiceListing$specific_servicesArgs<ExtArgs>
    _count?: boolean | ServiceListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }
  export type ServiceListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }

  export type $ServiceListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceListing"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      serviceProvider: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
      specific_services: Prisma.$SpecificServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      service_id: number
      service_title: string
      service_description: string
      service_startingprice: number
      provider_id: number
      servicelisting_isActive: boolean
      service_picture: string | null
    }, ExtArgs["result"]["serviceListing"]>
    composites: {}
  }

  type ServiceListingGetPayload<S extends boolean | null | undefined | ServiceListingDefaultArgs> = $Result.GetResult<Prisma.$ServiceListingPayload, S>

  type ServiceListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceListingCountAggregateInputType | true
    }

  export interface ServiceListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceListing'], meta: { name: 'ServiceListing' } }
    /**
     * Find zero or one ServiceListing that matches the filter.
     * @param {ServiceListingFindUniqueArgs} args - Arguments to find a ServiceListing
     * @example
     * // Get one ServiceListing
     * const serviceListing = await prisma.serviceListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceListingFindUniqueArgs>(args: SelectSubset<T, ServiceListingFindUniqueArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceListingFindUniqueOrThrowArgs} args - Arguments to find a ServiceListing
     * @example
     * // Get one ServiceListing
     * const serviceListing = await prisma.serviceListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingFindFirstArgs} args - Arguments to find a ServiceListing
     * @example
     * // Get one ServiceListing
     * const serviceListing = await prisma.serviceListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceListingFindFirstArgs>(args?: SelectSubset<T, ServiceListingFindFirstArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingFindFirstOrThrowArgs} args - Arguments to find a ServiceListing
     * @example
     * // Get one ServiceListing
     * const serviceListing = await prisma.serviceListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceListings
     * const serviceListings = await prisma.serviceListing.findMany()
     * 
     * // Get first 10 ServiceListings
     * const serviceListings = await prisma.serviceListing.findMany({ take: 10 })
     * 
     * // Only select the `service_id`
     * const serviceListingWithService_idOnly = await prisma.serviceListing.findMany({ select: { service_id: true } })
     * 
     */
    findMany<T extends ServiceListingFindManyArgs>(args?: SelectSubset<T, ServiceListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceListing.
     * @param {ServiceListingCreateArgs} args - Arguments to create a ServiceListing.
     * @example
     * // Create one ServiceListing
     * const ServiceListing = await prisma.serviceListing.create({
     *   data: {
     *     // ... data to create a ServiceListing
     *   }
     * })
     * 
     */
    create<T extends ServiceListingCreateArgs>(args: SelectSubset<T, ServiceListingCreateArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceListings.
     * @param {ServiceListingCreateManyArgs} args - Arguments to create many ServiceListings.
     * @example
     * // Create many ServiceListings
     * const serviceListing = await prisma.serviceListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceListingCreateManyArgs>(args?: SelectSubset<T, ServiceListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceListings and returns the data saved in the database.
     * @param {ServiceListingCreateManyAndReturnArgs} args - Arguments to create many ServiceListings.
     * @example
     * // Create many ServiceListings
     * const serviceListing = await prisma.serviceListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceListings and only return the `service_id`
     * const serviceListingWithService_idOnly = await prisma.serviceListing.createManyAndReturn({
     *   select: { service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceListing.
     * @param {ServiceListingDeleteArgs} args - Arguments to delete one ServiceListing.
     * @example
     * // Delete one ServiceListing
     * const ServiceListing = await prisma.serviceListing.delete({
     *   where: {
     *     // ... filter to delete one ServiceListing
     *   }
     * })
     * 
     */
    delete<T extends ServiceListingDeleteArgs>(args: SelectSubset<T, ServiceListingDeleteArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceListing.
     * @param {ServiceListingUpdateArgs} args - Arguments to update one ServiceListing.
     * @example
     * // Update one ServiceListing
     * const serviceListing = await prisma.serviceListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceListingUpdateArgs>(args: SelectSubset<T, ServiceListingUpdateArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceListings.
     * @param {ServiceListingDeleteManyArgs} args - Arguments to filter ServiceListings to delete.
     * @example
     * // Delete a few ServiceListings
     * const { count } = await prisma.serviceListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceListingDeleteManyArgs>(args?: SelectSubset<T, ServiceListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceListings
     * const serviceListing = await prisma.serviceListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceListingUpdateManyArgs>(args: SelectSubset<T, ServiceListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceListings and returns the data updated in the database.
     * @param {ServiceListingUpdateManyAndReturnArgs} args - Arguments to update many ServiceListings.
     * @example
     * // Update many ServiceListings
     * const serviceListing = await prisma.serviceListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceListings and only return the `service_id`
     * const serviceListingWithService_idOnly = await prisma.serviceListing.updateManyAndReturn({
     *   select: { service_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceListingUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceListing.
     * @param {ServiceListingUpsertArgs} args - Arguments to update or create a ServiceListing.
     * @example
     * // Update or create a ServiceListing
     * const serviceListing = await prisma.serviceListing.upsert({
     *   create: {
     *     // ... data to create a ServiceListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceListing we want to update
     *   }
     * })
     */
    upsert<T extends ServiceListingUpsertArgs>(args: SelectSubset<T, ServiceListingUpsertArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingCountArgs} args - Arguments to filter ServiceListings to count.
     * @example
     * // Count the number of ServiceListings
     * const count = await prisma.serviceListing.count({
     *   where: {
     *     // ... the filter for the ServiceListings we want to count
     *   }
     * })
    **/
    count<T extends ServiceListingCountArgs>(
      args?: Subset<T, ServiceListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceListingAggregateArgs>(args: Subset<T, ServiceListingAggregateArgs>): Prisma.PrismaPromise<GetServiceListingAggregateType<T>>

    /**
     * Group by ServiceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceListingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceListing model
   */
  readonly fields: ServiceListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends ServiceListing$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceListing$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceProvider<T extends ServiceProviderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetailsDefaultArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specific_services<T extends ServiceListing$specific_servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceListing$specific_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceListing model
   */
  interface ServiceListingFieldRefs {
    readonly service_id: FieldRef<"ServiceListing", 'Int'>
    readonly service_title: FieldRef<"ServiceListing", 'String'>
    readonly service_description: FieldRef<"ServiceListing", 'String'>
    readonly service_startingprice: FieldRef<"ServiceListing", 'Float'>
    readonly provider_id: FieldRef<"ServiceListing", 'Int'>
    readonly servicelisting_isActive: FieldRef<"ServiceListing", 'Boolean'>
    readonly service_picture: FieldRef<"ServiceListing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceListing findUnique
   */
  export type ServiceListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceListing to fetch.
     */
    where: ServiceListingWhereUniqueInput
  }

  /**
   * ServiceListing findUniqueOrThrow
   */
  export type ServiceListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceListing to fetch.
     */
    where: ServiceListingWhereUniqueInput
  }

  /**
   * ServiceListing findFirst
   */
  export type ServiceListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceListing to fetch.
     */
    where?: ServiceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceListings to fetch.
     */
    orderBy?: ServiceListingOrderByWithRelationInput | ServiceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceListings.
     */
    cursor?: ServiceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceListings.
     */
    distinct?: ServiceListingScalarFieldEnum | ServiceListingScalarFieldEnum[]
  }

  /**
   * ServiceListing findFirstOrThrow
   */
  export type ServiceListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceListing to fetch.
     */
    where?: ServiceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceListings to fetch.
     */
    orderBy?: ServiceListingOrderByWithRelationInput | ServiceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceListings.
     */
    cursor?: ServiceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceListings.
     */
    distinct?: ServiceListingScalarFieldEnum | ServiceListingScalarFieldEnum[]
  }

  /**
   * ServiceListing findMany
   */
  export type ServiceListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceListings to fetch.
     */
    where?: ServiceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceListings to fetch.
     */
    orderBy?: ServiceListingOrderByWithRelationInput | ServiceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceListings.
     */
    cursor?: ServiceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceListings.
     */
    skip?: number
    distinct?: ServiceListingScalarFieldEnum | ServiceListingScalarFieldEnum[]
  }

  /**
   * ServiceListing create
   */
  export type ServiceListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceListing.
     */
    data: XOR<ServiceListingCreateInput, ServiceListingUncheckedCreateInput>
  }

  /**
   * ServiceListing createMany
   */
  export type ServiceListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceListings.
     */
    data: ServiceListingCreateManyInput | ServiceListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceListing createManyAndReturn
   */
  export type ServiceListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceListings.
     */
    data: ServiceListingCreateManyInput | ServiceListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceListing update
   */
  export type ServiceListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceListing.
     */
    data: XOR<ServiceListingUpdateInput, ServiceListingUncheckedUpdateInput>
    /**
     * Choose, which ServiceListing to update.
     */
    where: ServiceListingWhereUniqueInput
  }

  /**
   * ServiceListing updateMany
   */
  export type ServiceListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceListings.
     */
    data: XOR<ServiceListingUpdateManyMutationInput, ServiceListingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceListings to update
     */
    where?: ServiceListingWhereInput
    /**
     * Limit how many ServiceListings to update.
     */
    limit?: number
  }

  /**
   * ServiceListing updateManyAndReturn
   */
  export type ServiceListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * The data used to update ServiceListings.
     */
    data: XOR<ServiceListingUpdateManyMutationInput, ServiceListingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceListings to update
     */
    where?: ServiceListingWhereInput
    /**
     * Limit how many ServiceListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceListing upsert
   */
  export type ServiceListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceListing to update in case it exists.
     */
    where: ServiceListingWhereUniqueInput
    /**
     * In case the ServiceListing found by the `where` argument doesn't exist, create a new ServiceListing with this data.
     */
    create: XOR<ServiceListingCreateInput, ServiceListingUncheckedCreateInput>
    /**
     * In case the ServiceListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceListingUpdateInput, ServiceListingUncheckedUpdateInput>
  }

  /**
   * ServiceListing delete
   */
  export type ServiceListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
    /**
     * Filter which ServiceListing to delete.
     */
    where: ServiceListingWhereUniqueInput
  }

  /**
   * ServiceListing deleteMany
   */
  export type ServiceListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceListings to delete
     */
    where?: ServiceListingWhereInput
    /**
     * Limit how many ServiceListings to delete.
     */
    limit?: number
  }

  /**
   * ServiceListing.appointments
   */
  export type ServiceListing$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * ServiceListing.specific_services
   */
  export type ServiceListing$specific_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    where?: SpecificServiceWhereInput
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    cursor?: SpecificServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificServiceScalarFieldEnum | SpecificServiceScalarFieldEnum[]
  }

  /**
   * ServiceListing without action
   */
  export type ServiceListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceListing
     */
    select?: ServiceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceListing
     */
    omit?: ServiceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceListingInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _avg: ServiceCategoryAvgAggregateOutputType | null
    _sum: ServiceCategorySumAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryAvgAggregateOutputType = {
    category_id: number | null
  }

  export type ServiceCategorySumAggregateOutputType = {
    category_id: number | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    category_id: number | null
    category_name: string | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    category_id: number | null
    category_name: string | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    category_id: number
    category_name: number
    _all: number
  }


  export type ServiceCategoryAvgAggregateInputType = {
    category_id?: true
  }

  export type ServiceCategorySumAggregateInputType = {
    category_id?: true
  }

  export type ServiceCategoryMinAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    category_id?: true
    category_name?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _avg?: ServiceCategoryAvgAggregateInputType
    _sum?: ServiceCategorySumAggregateInputType
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    category_id: number
    category_name: string
    _count: ServiceCategoryCountAggregateOutputType | null
    _avg: ServiceCategoryAvgAggregateOutputType | null
    _sum: ServiceCategorySumAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
    specific_services?: boolean | ServiceCategory$specific_servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    category_id?: boolean
    category_name?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"category_id" | "category_name", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specific_services?: boolean | ServiceCategory$specific_servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      specific_services: Prisma.$SpecificServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      category_id: number
      category_name: string
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `category_id`
     * const serviceCategoryWithCategory_idOnly = await prisma.serviceCategory.findMany({ select: { category_id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `category_id`
     * const serviceCategoryWithCategory_idOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { category_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `category_id`
     * const serviceCategoryWithCategory_idOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { category_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specific_services<T extends ServiceCategory$specific_servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$specific_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly category_id: FieldRef<"ServiceCategory", 'Int'>
    readonly category_name: FieldRef<"ServiceCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.specific_services
   */
  export type ServiceCategory$specific_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    where?: SpecificServiceWhereInput
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    cursor?: SpecificServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificServiceScalarFieldEnum | SpecificServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model SpecificService
   */

  export type AggregateSpecificService = {
    _count: SpecificServiceCountAggregateOutputType | null
    _avg: SpecificServiceAvgAggregateOutputType | null
    _sum: SpecificServiceSumAggregateOutputType | null
    _min: SpecificServiceMinAggregateOutputType | null
    _max: SpecificServiceMaxAggregateOutputType | null
  }

  export type SpecificServiceAvgAggregateOutputType = {
    specific_service_id: number | null
    service_id: number | null
    category_id: number | null
  }

  export type SpecificServiceSumAggregateOutputType = {
    specific_service_id: number | null
    service_id: number | null
    category_id: number | null
  }

  export type SpecificServiceMinAggregateOutputType = {
    specific_service_id: number | null
    specific_service_title: string | null
    specific_service_description: string | null
    service_id: number | null
    category_id: number | null
  }

  export type SpecificServiceMaxAggregateOutputType = {
    specific_service_id: number | null
    specific_service_title: string | null
    specific_service_description: string | null
    service_id: number | null
    category_id: number | null
  }

  export type SpecificServiceCountAggregateOutputType = {
    specific_service_id: number
    specific_service_title: number
    specific_service_description: number
    service_id: number
    category_id: number
    _all: number
  }


  export type SpecificServiceAvgAggregateInputType = {
    specific_service_id?: true
    service_id?: true
    category_id?: true
  }

  export type SpecificServiceSumAggregateInputType = {
    specific_service_id?: true
    service_id?: true
    category_id?: true
  }

  export type SpecificServiceMinAggregateInputType = {
    specific_service_id?: true
    specific_service_title?: true
    specific_service_description?: true
    service_id?: true
    category_id?: true
  }

  export type SpecificServiceMaxAggregateInputType = {
    specific_service_id?: true
    specific_service_title?: true
    specific_service_description?: true
    service_id?: true
    category_id?: true
  }

  export type SpecificServiceCountAggregateInputType = {
    specific_service_id?: true
    specific_service_title?: true
    specific_service_description?: true
    service_id?: true
    category_id?: true
    _all?: true
  }

  export type SpecificServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificService to aggregate.
     */
    where?: SpecificServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificServices to fetch.
     */
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecificServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecificServices
    **/
    _count?: true | SpecificServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecificServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecificServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecificServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecificServiceMaxAggregateInputType
  }

  export type GetSpecificServiceAggregateType<T extends SpecificServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecificService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecificService[P]>
      : GetScalarType<T[P], AggregateSpecificService[P]>
  }




  export type SpecificServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificServiceWhereInput
    orderBy?: SpecificServiceOrderByWithAggregationInput | SpecificServiceOrderByWithAggregationInput[]
    by: SpecificServiceScalarFieldEnum[] | SpecificServiceScalarFieldEnum
    having?: SpecificServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecificServiceCountAggregateInputType | true
    _avg?: SpecificServiceAvgAggregateInputType
    _sum?: SpecificServiceSumAggregateInputType
    _min?: SpecificServiceMinAggregateInputType
    _max?: SpecificServiceMaxAggregateInputType
  }

  export type SpecificServiceGroupByOutputType = {
    specific_service_id: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
    category_id: number
    _count: SpecificServiceCountAggregateOutputType | null
    _avg: SpecificServiceAvgAggregateOutputType | null
    _sum: SpecificServiceSumAggregateOutputType | null
    _min: SpecificServiceMinAggregateOutputType | null
    _max: SpecificServiceMaxAggregateOutputType | null
  }

  type GetSpecificServiceGroupByPayload<T extends SpecificServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecificServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecificServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecificServiceGroupByOutputType[P]>
            : GetScalarType<T[P], SpecificServiceGroupByOutputType[P]>
        }
      >
    >


  export type SpecificServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    specific_service_id?: boolean
    specific_service_title?: boolean
    specific_service_description?: boolean
    service_id?: boolean
    category_id?: boolean
    covered_by_certificates?: boolean | SpecificService$covered_by_certificatesArgs<ExtArgs>
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
    _count?: boolean | SpecificServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificService"]>

  export type SpecificServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    specific_service_id?: boolean
    specific_service_title?: boolean
    specific_service_description?: boolean
    service_id?: boolean
    category_id?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificService"]>

  export type SpecificServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    specific_service_id?: boolean
    specific_service_title?: boolean
    specific_service_description?: boolean
    service_id?: boolean
    category_id?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificService"]>

  export type SpecificServiceSelectScalar = {
    specific_service_id?: boolean
    specific_service_title?: boolean
    specific_service_description?: boolean
    service_id?: boolean
    category_id?: boolean
  }

  export type SpecificServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"specific_service_id" | "specific_service_title" | "specific_service_description" | "service_id" | "category_id", ExtArgs["result"]["specificService"]>
  export type SpecificServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    covered_by_certificates?: boolean | SpecificService$covered_by_certificatesArgs<ExtArgs>
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
    _count?: boolean | SpecificServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecificServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }
  export type SpecificServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    serviceListing?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }

  export type $SpecificServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecificService"
    objects: {
      covered_by_certificates: Prisma.$CoveredServicePayload<ExtArgs>[]
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
      serviceListing: Prisma.$ServiceListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      specific_service_id: number
      specific_service_title: string
      specific_service_description: string
      service_id: number
      category_id: number
    }, ExtArgs["result"]["specificService"]>
    composites: {}
  }

  type SpecificServiceGetPayload<S extends boolean | null | undefined | SpecificServiceDefaultArgs> = $Result.GetResult<Prisma.$SpecificServicePayload, S>

  type SpecificServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecificServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecificServiceCountAggregateInputType | true
    }

  export interface SpecificServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecificService'], meta: { name: 'SpecificService' } }
    /**
     * Find zero or one SpecificService that matches the filter.
     * @param {SpecificServiceFindUniqueArgs} args - Arguments to find a SpecificService
     * @example
     * // Get one SpecificService
     * const specificService = await prisma.specificService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecificServiceFindUniqueArgs>(args: SelectSubset<T, SpecificServiceFindUniqueArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecificService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecificServiceFindUniqueOrThrowArgs} args - Arguments to find a SpecificService
     * @example
     * // Get one SpecificService
     * const specificService = await prisma.specificService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecificServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecificServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecificService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceFindFirstArgs} args - Arguments to find a SpecificService
     * @example
     * // Get one SpecificService
     * const specificService = await prisma.specificService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecificServiceFindFirstArgs>(args?: SelectSubset<T, SpecificServiceFindFirstArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecificService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceFindFirstOrThrowArgs} args - Arguments to find a SpecificService
     * @example
     * // Get one SpecificService
     * const specificService = await prisma.specificService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecificServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecificServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecificServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecificServices
     * const specificServices = await prisma.specificService.findMany()
     * 
     * // Get first 10 SpecificServices
     * const specificServices = await prisma.specificService.findMany({ take: 10 })
     * 
     * // Only select the `specific_service_id`
     * const specificServiceWithSpecific_service_idOnly = await prisma.specificService.findMany({ select: { specific_service_id: true } })
     * 
     */
    findMany<T extends SpecificServiceFindManyArgs>(args?: SelectSubset<T, SpecificServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecificService.
     * @param {SpecificServiceCreateArgs} args - Arguments to create a SpecificService.
     * @example
     * // Create one SpecificService
     * const SpecificService = await prisma.specificService.create({
     *   data: {
     *     // ... data to create a SpecificService
     *   }
     * })
     * 
     */
    create<T extends SpecificServiceCreateArgs>(args: SelectSubset<T, SpecificServiceCreateArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecificServices.
     * @param {SpecificServiceCreateManyArgs} args - Arguments to create many SpecificServices.
     * @example
     * // Create many SpecificServices
     * const specificService = await prisma.specificService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecificServiceCreateManyArgs>(args?: SelectSubset<T, SpecificServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecificServices and returns the data saved in the database.
     * @param {SpecificServiceCreateManyAndReturnArgs} args - Arguments to create many SpecificServices.
     * @example
     * // Create many SpecificServices
     * const specificService = await prisma.specificService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecificServices and only return the `specific_service_id`
     * const specificServiceWithSpecific_service_idOnly = await prisma.specificService.createManyAndReturn({
     *   select: { specific_service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecificServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecificServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecificService.
     * @param {SpecificServiceDeleteArgs} args - Arguments to delete one SpecificService.
     * @example
     * // Delete one SpecificService
     * const SpecificService = await prisma.specificService.delete({
     *   where: {
     *     // ... filter to delete one SpecificService
     *   }
     * })
     * 
     */
    delete<T extends SpecificServiceDeleteArgs>(args: SelectSubset<T, SpecificServiceDeleteArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecificService.
     * @param {SpecificServiceUpdateArgs} args - Arguments to update one SpecificService.
     * @example
     * // Update one SpecificService
     * const specificService = await prisma.specificService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecificServiceUpdateArgs>(args: SelectSubset<T, SpecificServiceUpdateArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecificServices.
     * @param {SpecificServiceDeleteManyArgs} args - Arguments to filter SpecificServices to delete.
     * @example
     * // Delete a few SpecificServices
     * const { count } = await prisma.specificService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecificServiceDeleteManyArgs>(args?: SelectSubset<T, SpecificServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecificServices
     * const specificService = await prisma.specificService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecificServiceUpdateManyArgs>(args: SelectSubset<T, SpecificServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificServices and returns the data updated in the database.
     * @param {SpecificServiceUpdateManyAndReturnArgs} args - Arguments to update many SpecificServices.
     * @example
     * // Update many SpecificServices
     * const specificService = await prisma.specificService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecificServices and only return the `specific_service_id`
     * const specificServiceWithSpecific_service_idOnly = await prisma.specificService.updateManyAndReturn({
     *   select: { specific_service_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecificServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecificServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecificService.
     * @param {SpecificServiceUpsertArgs} args - Arguments to update or create a SpecificService.
     * @example
     * // Update or create a SpecificService
     * const specificService = await prisma.specificService.upsert({
     *   create: {
     *     // ... data to create a SpecificService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecificService we want to update
     *   }
     * })
     */
    upsert<T extends SpecificServiceUpsertArgs>(args: SelectSubset<T, SpecificServiceUpsertArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecificServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceCountArgs} args - Arguments to filter SpecificServices to count.
     * @example
     * // Count the number of SpecificServices
     * const count = await prisma.specificService.count({
     *   where: {
     *     // ... the filter for the SpecificServices we want to count
     *   }
     * })
    **/
    count<T extends SpecificServiceCountArgs>(
      args?: Subset<T, SpecificServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecificServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecificService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecificServiceAggregateArgs>(args: Subset<T, SpecificServiceAggregateArgs>): Prisma.PrismaPromise<GetSpecificServiceAggregateType<T>>

    /**
     * Group by SpecificService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecificServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecificServiceGroupByArgs['orderBy'] }
        : { orderBy?: SpecificServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecificServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecificServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecificService model
   */
  readonly fields: SpecificServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecificService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecificServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    covered_by_certificates<T extends SpecificService$covered_by_certificatesArgs<ExtArgs> = {}>(args?: Subset<T, SpecificService$covered_by_certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceListing<T extends ServiceListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceListingDefaultArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecificService model
   */
  interface SpecificServiceFieldRefs {
    readonly specific_service_id: FieldRef<"SpecificService", 'Int'>
    readonly specific_service_title: FieldRef<"SpecificService", 'String'>
    readonly specific_service_description: FieldRef<"SpecificService", 'String'>
    readonly service_id: FieldRef<"SpecificService", 'Int'>
    readonly category_id: FieldRef<"SpecificService", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpecificService findUnique
   */
  export type SpecificServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter, which SpecificService to fetch.
     */
    where: SpecificServiceWhereUniqueInput
  }

  /**
   * SpecificService findUniqueOrThrow
   */
  export type SpecificServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter, which SpecificService to fetch.
     */
    where: SpecificServiceWhereUniqueInput
  }

  /**
   * SpecificService findFirst
   */
  export type SpecificServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter, which SpecificService to fetch.
     */
    where?: SpecificServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificServices to fetch.
     */
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificServices.
     */
    cursor?: SpecificServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificServices.
     */
    distinct?: SpecificServiceScalarFieldEnum | SpecificServiceScalarFieldEnum[]
  }

  /**
   * SpecificService findFirstOrThrow
   */
  export type SpecificServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter, which SpecificService to fetch.
     */
    where?: SpecificServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificServices to fetch.
     */
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificServices.
     */
    cursor?: SpecificServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificServices.
     */
    distinct?: SpecificServiceScalarFieldEnum | SpecificServiceScalarFieldEnum[]
  }

  /**
   * SpecificService findMany
   */
  export type SpecificServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter, which SpecificServices to fetch.
     */
    where?: SpecificServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificServices to fetch.
     */
    orderBy?: SpecificServiceOrderByWithRelationInput | SpecificServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecificServices.
     */
    cursor?: SpecificServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificServices.
     */
    skip?: number
    distinct?: SpecificServiceScalarFieldEnum | SpecificServiceScalarFieldEnum[]
  }

  /**
   * SpecificService create
   */
  export type SpecificServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecificService.
     */
    data: XOR<SpecificServiceCreateInput, SpecificServiceUncheckedCreateInput>
  }

  /**
   * SpecificService createMany
   */
  export type SpecificServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecificServices.
     */
    data: SpecificServiceCreateManyInput | SpecificServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecificService createManyAndReturn
   */
  export type SpecificServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * The data used to create many SpecificServices.
     */
    data: SpecificServiceCreateManyInput | SpecificServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecificService update
   */
  export type SpecificServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecificService.
     */
    data: XOR<SpecificServiceUpdateInput, SpecificServiceUncheckedUpdateInput>
    /**
     * Choose, which SpecificService to update.
     */
    where: SpecificServiceWhereUniqueInput
  }

  /**
   * SpecificService updateMany
   */
  export type SpecificServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecificServices.
     */
    data: XOR<SpecificServiceUpdateManyMutationInput, SpecificServiceUncheckedUpdateManyInput>
    /**
     * Filter which SpecificServices to update
     */
    where?: SpecificServiceWhereInput
    /**
     * Limit how many SpecificServices to update.
     */
    limit?: number
  }

  /**
   * SpecificService updateManyAndReturn
   */
  export type SpecificServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * The data used to update SpecificServices.
     */
    data: XOR<SpecificServiceUpdateManyMutationInput, SpecificServiceUncheckedUpdateManyInput>
    /**
     * Filter which SpecificServices to update
     */
    where?: SpecificServiceWhereInput
    /**
     * Limit how many SpecificServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecificService upsert
   */
  export type SpecificServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecificService to update in case it exists.
     */
    where: SpecificServiceWhereUniqueInput
    /**
     * In case the SpecificService found by the `where` argument doesn't exist, create a new SpecificService with this data.
     */
    create: XOR<SpecificServiceCreateInput, SpecificServiceUncheckedCreateInput>
    /**
     * In case the SpecificService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecificServiceUpdateInput, SpecificServiceUncheckedUpdateInput>
  }

  /**
   * SpecificService delete
   */
  export type SpecificServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
    /**
     * Filter which SpecificService to delete.
     */
    where: SpecificServiceWhereUniqueInput
  }

  /**
   * SpecificService deleteMany
   */
  export type SpecificServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificServices to delete
     */
    where?: SpecificServiceWhereInput
    /**
     * Limit how many SpecificServices to delete.
     */
    limit?: number
  }

  /**
   * SpecificService.covered_by_certificates
   */
  export type SpecificService$covered_by_certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    where?: CoveredServiceWhereInput
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    cursor?: CoveredServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoveredServiceScalarFieldEnum | CoveredServiceScalarFieldEnum[]
  }

  /**
   * SpecificService without action
   */
  export type SpecificServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificService
     */
    select?: SpecificServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificService
     */
    omit?: SpecificServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificServiceInclude<ExtArgs> | null
  }


  /**
   * Model CoveredService
   */

  export type AggregateCoveredService = {
    _count: CoveredServiceCountAggregateOutputType | null
    _avg: CoveredServiceAvgAggregateOutputType | null
    _sum: CoveredServiceSumAggregateOutputType | null
    _min: CoveredServiceMinAggregateOutputType | null
    _max: CoveredServiceMaxAggregateOutputType | null
  }

  export type CoveredServiceAvgAggregateOutputType = {
    covered_service_id: number | null
    specific_service_id: number | null
    certificate_id: number | null
  }

  export type CoveredServiceSumAggregateOutputType = {
    covered_service_id: number | null
    specific_service_id: number | null
    certificate_id: number | null
  }

  export type CoveredServiceMinAggregateOutputType = {
    covered_service_id: number | null
    specific_service_id: number | null
    certificate_id: number | null
  }

  export type CoveredServiceMaxAggregateOutputType = {
    covered_service_id: number | null
    specific_service_id: number | null
    certificate_id: number | null
  }

  export type CoveredServiceCountAggregateOutputType = {
    covered_service_id: number
    specific_service_id: number
    certificate_id: number
    _all: number
  }


  export type CoveredServiceAvgAggregateInputType = {
    covered_service_id?: true
    specific_service_id?: true
    certificate_id?: true
  }

  export type CoveredServiceSumAggregateInputType = {
    covered_service_id?: true
    specific_service_id?: true
    certificate_id?: true
  }

  export type CoveredServiceMinAggregateInputType = {
    covered_service_id?: true
    specific_service_id?: true
    certificate_id?: true
  }

  export type CoveredServiceMaxAggregateInputType = {
    covered_service_id?: true
    specific_service_id?: true
    certificate_id?: true
  }

  export type CoveredServiceCountAggregateInputType = {
    covered_service_id?: true
    specific_service_id?: true
    certificate_id?: true
    _all?: true
  }

  export type CoveredServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoveredService to aggregate.
     */
    where?: CoveredServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoveredServices to fetch.
     */
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoveredServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoveredServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoveredServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoveredServices
    **/
    _count?: true | CoveredServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoveredServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoveredServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoveredServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoveredServiceMaxAggregateInputType
  }

  export type GetCoveredServiceAggregateType<T extends CoveredServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCoveredService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoveredService[P]>
      : GetScalarType<T[P], AggregateCoveredService[P]>
  }




  export type CoveredServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoveredServiceWhereInput
    orderBy?: CoveredServiceOrderByWithAggregationInput | CoveredServiceOrderByWithAggregationInput[]
    by: CoveredServiceScalarFieldEnum[] | CoveredServiceScalarFieldEnum
    having?: CoveredServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoveredServiceCountAggregateInputType | true
    _avg?: CoveredServiceAvgAggregateInputType
    _sum?: CoveredServiceSumAggregateInputType
    _min?: CoveredServiceMinAggregateInputType
    _max?: CoveredServiceMaxAggregateInputType
  }

  export type CoveredServiceGroupByOutputType = {
    covered_service_id: number
    specific_service_id: number
    certificate_id: number
    _count: CoveredServiceCountAggregateOutputType | null
    _avg: CoveredServiceAvgAggregateOutputType | null
    _sum: CoveredServiceSumAggregateOutputType | null
    _min: CoveredServiceMinAggregateOutputType | null
    _max: CoveredServiceMaxAggregateOutputType | null
  }

  type GetCoveredServiceGroupByPayload<T extends CoveredServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoveredServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoveredServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoveredServiceGroupByOutputType[P]>
            : GetScalarType<T[P], CoveredServiceGroupByOutputType[P]>
        }
      >
    >


  export type CoveredServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    covered_service_id?: boolean
    specific_service_id?: boolean
    certificate_id?: boolean
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coveredService"]>

  export type CoveredServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    covered_service_id?: boolean
    specific_service_id?: boolean
    certificate_id?: boolean
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coveredService"]>

  export type CoveredServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    covered_service_id?: boolean
    specific_service_id?: boolean
    certificate_id?: boolean
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coveredService"]>

  export type CoveredServiceSelectScalar = {
    covered_service_id?: boolean
    specific_service_id?: boolean
    certificate_id?: boolean
  }

  export type CoveredServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"covered_service_id" | "specific_service_id" | "certificate_id", ExtArgs["result"]["coveredService"]>
  export type CoveredServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }
  export type CoveredServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }
  export type CoveredServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | CertificateDefaultArgs<ExtArgs>
    specific_service?: boolean | SpecificServiceDefaultArgs<ExtArgs>
  }

  export type $CoveredServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoveredService"
    objects: {
      certificate: Prisma.$CertificatePayload<ExtArgs>
      specific_service: Prisma.$SpecificServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      covered_service_id: number
      specific_service_id: number
      certificate_id: number
    }, ExtArgs["result"]["coveredService"]>
    composites: {}
  }

  type CoveredServiceGetPayload<S extends boolean | null | undefined | CoveredServiceDefaultArgs> = $Result.GetResult<Prisma.$CoveredServicePayload, S>

  type CoveredServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoveredServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoveredServiceCountAggregateInputType | true
    }

  export interface CoveredServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoveredService'], meta: { name: 'CoveredService' } }
    /**
     * Find zero or one CoveredService that matches the filter.
     * @param {CoveredServiceFindUniqueArgs} args - Arguments to find a CoveredService
     * @example
     * // Get one CoveredService
     * const coveredService = await prisma.coveredService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoveredServiceFindUniqueArgs>(args: SelectSubset<T, CoveredServiceFindUniqueArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoveredService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoveredServiceFindUniqueOrThrowArgs} args - Arguments to find a CoveredService
     * @example
     * // Get one CoveredService
     * const coveredService = await prisma.coveredService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoveredServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CoveredServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoveredService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceFindFirstArgs} args - Arguments to find a CoveredService
     * @example
     * // Get one CoveredService
     * const coveredService = await prisma.coveredService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoveredServiceFindFirstArgs>(args?: SelectSubset<T, CoveredServiceFindFirstArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoveredService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceFindFirstOrThrowArgs} args - Arguments to find a CoveredService
     * @example
     * // Get one CoveredService
     * const coveredService = await prisma.coveredService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoveredServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CoveredServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoveredServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoveredServices
     * const coveredServices = await prisma.coveredService.findMany()
     * 
     * // Get first 10 CoveredServices
     * const coveredServices = await prisma.coveredService.findMany({ take: 10 })
     * 
     * // Only select the `covered_service_id`
     * const coveredServiceWithCovered_service_idOnly = await prisma.coveredService.findMany({ select: { covered_service_id: true } })
     * 
     */
    findMany<T extends CoveredServiceFindManyArgs>(args?: SelectSubset<T, CoveredServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoveredService.
     * @param {CoveredServiceCreateArgs} args - Arguments to create a CoveredService.
     * @example
     * // Create one CoveredService
     * const CoveredService = await prisma.coveredService.create({
     *   data: {
     *     // ... data to create a CoveredService
     *   }
     * })
     * 
     */
    create<T extends CoveredServiceCreateArgs>(args: SelectSubset<T, CoveredServiceCreateArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoveredServices.
     * @param {CoveredServiceCreateManyArgs} args - Arguments to create many CoveredServices.
     * @example
     * // Create many CoveredServices
     * const coveredService = await prisma.coveredService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoveredServiceCreateManyArgs>(args?: SelectSubset<T, CoveredServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoveredServices and returns the data saved in the database.
     * @param {CoveredServiceCreateManyAndReturnArgs} args - Arguments to create many CoveredServices.
     * @example
     * // Create many CoveredServices
     * const coveredService = await prisma.coveredService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoveredServices and only return the `covered_service_id`
     * const coveredServiceWithCovered_service_idOnly = await prisma.coveredService.createManyAndReturn({
     *   select: { covered_service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoveredServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CoveredServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoveredService.
     * @param {CoveredServiceDeleteArgs} args - Arguments to delete one CoveredService.
     * @example
     * // Delete one CoveredService
     * const CoveredService = await prisma.coveredService.delete({
     *   where: {
     *     // ... filter to delete one CoveredService
     *   }
     * })
     * 
     */
    delete<T extends CoveredServiceDeleteArgs>(args: SelectSubset<T, CoveredServiceDeleteArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoveredService.
     * @param {CoveredServiceUpdateArgs} args - Arguments to update one CoveredService.
     * @example
     * // Update one CoveredService
     * const coveredService = await prisma.coveredService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoveredServiceUpdateArgs>(args: SelectSubset<T, CoveredServiceUpdateArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoveredServices.
     * @param {CoveredServiceDeleteManyArgs} args - Arguments to filter CoveredServices to delete.
     * @example
     * // Delete a few CoveredServices
     * const { count } = await prisma.coveredService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoveredServiceDeleteManyArgs>(args?: SelectSubset<T, CoveredServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoveredServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoveredServices
     * const coveredService = await prisma.coveredService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoveredServiceUpdateManyArgs>(args: SelectSubset<T, CoveredServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoveredServices and returns the data updated in the database.
     * @param {CoveredServiceUpdateManyAndReturnArgs} args - Arguments to update many CoveredServices.
     * @example
     * // Update many CoveredServices
     * const coveredService = await prisma.coveredService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoveredServices and only return the `covered_service_id`
     * const coveredServiceWithCovered_service_idOnly = await prisma.coveredService.updateManyAndReturn({
     *   select: { covered_service_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoveredServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CoveredServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoveredService.
     * @param {CoveredServiceUpsertArgs} args - Arguments to update or create a CoveredService.
     * @example
     * // Update or create a CoveredService
     * const coveredService = await prisma.coveredService.upsert({
     *   create: {
     *     // ... data to create a CoveredService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoveredService we want to update
     *   }
     * })
     */
    upsert<T extends CoveredServiceUpsertArgs>(args: SelectSubset<T, CoveredServiceUpsertArgs<ExtArgs>>): Prisma__CoveredServiceClient<$Result.GetResult<Prisma.$CoveredServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoveredServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceCountArgs} args - Arguments to filter CoveredServices to count.
     * @example
     * // Count the number of CoveredServices
     * const count = await prisma.coveredService.count({
     *   where: {
     *     // ... the filter for the CoveredServices we want to count
     *   }
     * })
    **/
    count<T extends CoveredServiceCountArgs>(
      args?: Subset<T, CoveredServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoveredServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoveredService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoveredServiceAggregateArgs>(args: Subset<T, CoveredServiceAggregateArgs>): Prisma.PrismaPromise<GetCoveredServiceAggregateType<T>>

    /**
     * Group by CoveredService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoveredServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoveredServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoveredServiceGroupByArgs['orderBy'] }
        : { orderBy?: CoveredServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoveredServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoveredServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoveredService model
   */
  readonly fields: CoveredServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoveredService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoveredServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificate<T extends CertificateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CertificateDefaultArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specific_service<T extends SpecificServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecificServiceDefaultArgs<ExtArgs>>): Prisma__SpecificServiceClient<$Result.GetResult<Prisma.$SpecificServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoveredService model
   */
  interface CoveredServiceFieldRefs {
    readonly covered_service_id: FieldRef<"CoveredService", 'Int'>
    readonly specific_service_id: FieldRef<"CoveredService", 'Int'>
    readonly certificate_id: FieldRef<"CoveredService", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CoveredService findUnique
   */
  export type CoveredServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter, which CoveredService to fetch.
     */
    where: CoveredServiceWhereUniqueInput
  }

  /**
   * CoveredService findUniqueOrThrow
   */
  export type CoveredServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter, which CoveredService to fetch.
     */
    where: CoveredServiceWhereUniqueInput
  }

  /**
   * CoveredService findFirst
   */
  export type CoveredServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter, which CoveredService to fetch.
     */
    where?: CoveredServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoveredServices to fetch.
     */
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoveredServices.
     */
    cursor?: CoveredServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoveredServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoveredServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoveredServices.
     */
    distinct?: CoveredServiceScalarFieldEnum | CoveredServiceScalarFieldEnum[]
  }

  /**
   * CoveredService findFirstOrThrow
   */
  export type CoveredServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter, which CoveredService to fetch.
     */
    where?: CoveredServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoveredServices to fetch.
     */
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoveredServices.
     */
    cursor?: CoveredServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoveredServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoveredServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoveredServices.
     */
    distinct?: CoveredServiceScalarFieldEnum | CoveredServiceScalarFieldEnum[]
  }

  /**
   * CoveredService findMany
   */
  export type CoveredServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter, which CoveredServices to fetch.
     */
    where?: CoveredServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoveredServices to fetch.
     */
    orderBy?: CoveredServiceOrderByWithRelationInput | CoveredServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoveredServices.
     */
    cursor?: CoveredServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoveredServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoveredServices.
     */
    skip?: number
    distinct?: CoveredServiceScalarFieldEnum | CoveredServiceScalarFieldEnum[]
  }

  /**
   * CoveredService create
   */
  export type CoveredServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CoveredService.
     */
    data: XOR<CoveredServiceCreateInput, CoveredServiceUncheckedCreateInput>
  }

  /**
   * CoveredService createMany
   */
  export type CoveredServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoveredServices.
     */
    data: CoveredServiceCreateManyInput | CoveredServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoveredService createManyAndReturn
   */
  export type CoveredServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * The data used to create many CoveredServices.
     */
    data: CoveredServiceCreateManyInput | CoveredServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoveredService update
   */
  export type CoveredServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CoveredService.
     */
    data: XOR<CoveredServiceUpdateInput, CoveredServiceUncheckedUpdateInput>
    /**
     * Choose, which CoveredService to update.
     */
    where: CoveredServiceWhereUniqueInput
  }

  /**
   * CoveredService updateMany
   */
  export type CoveredServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoveredServices.
     */
    data: XOR<CoveredServiceUpdateManyMutationInput, CoveredServiceUncheckedUpdateManyInput>
    /**
     * Filter which CoveredServices to update
     */
    where?: CoveredServiceWhereInput
    /**
     * Limit how many CoveredServices to update.
     */
    limit?: number
  }

  /**
   * CoveredService updateManyAndReturn
   */
  export type CoveredServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * The data used to update CoveredServices.
     */
    data: XOR<CoveredServiceUpdateManyMutationInput, CoveredServiceUncheckedUpdateManyInput>
    /**
     * Filter which CoveredServices to update
     */
    where?: CoveredServiceWhereInput
    /**
     * Limit how many CoveredServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoveredService upsert
   */
  export type CoveredServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CoveredService to update in case it exists.
     */
    where: CoveredServiceWhereUniqueInput
    /**
     * In case the CoveredService found by the `where` argument doesn't exist, create a new CoveredService with this data.
     */
    create: XOR<CoveredServiceCreateInput, CoveredServiceUncheckedCreateInput>
    /**
     * In case the CoveredService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoveredServiceUpdateInput, CoveredServiceUncheckedUpdateInput>
  }

  /**
   * CoveredService delete
   */
  export type CoveredServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
    /**
     * Filter which CoveredService to delete.
     */
    where: CoveredServiceWhereUniqueInput
  }

  /**
   * CoveredService deleteMany
   */
  export type CoveredServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoveredServices to delete
     */
    where?: CoveredServiceWhereInput
    /**
     * Limit how many CoveredServices to delete.
     */
    limit?: number
  }

  /**
   * CoveredService without action
   */
  export type CoveredServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoveredService
     */
    select?: CoveredServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoveredService
     */
    omit?: CoveredServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoveredServiceInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityAvgAggregateOutputType = {
    availability_id: number | null
    provider_id: number | null
  }

  export type AvailabilitySumAggregateOutputType = {
    availability_id: number | null
    provider_id: number | null
  }

  export type AvailabilityMinAggregateOutputType = {
    availability_id: number | null
    dayOfWeek: string | null
    startTime: string | null
    endTime: string | null
    provider_id: number | null
    availability_isActive: boolean | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    availability_id: number | null
    dayOfWeek: string | null
    startTime: string | null
    endTime: string | null
    provider_id: number | null
    availability_isActive: boolean | null
  }

  export type AvailabilityCountAggregateOutputType = {
    availability_id: number
    dayOfWeek: number
    startTime: number
    endTime: number
    provider_id: number
    availability_isActive: number
    _all: number
  }


  export type AvailabilityAvgAggregateInputType = {
    availability_id?: true
    provider_id?: true
  }

  export type AvailabilitySumAggregateInputType = {
    availability_id?: true
    provider_id?: true
  }

  export type AvailabilityMinAggregateInputType = {
    availability_id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    provider_id?: true
    availability_isActive?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    availability_id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    provider_id?: true
    availability_isActive?: true
  }

  export type AvailabilityCountAggregateInputType = {
    availability_id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    provider_id?: true
    availability_isActive?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _avg?: AvailabilityAvgAggregateInputType
    _sum?: AvailabilitySumAggregateInputType
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    availability_id: number
    dayOfWeek: string
    startTime: string
    endTime: string
    provider_id: number
    availability_isActive: boolean
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    availability_id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    provider_id?: boolean
    availability_isActive?: boolean
    appointments?: boolean | Availability$appointmentsArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    _count?: boolean | AvailabilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    availability_id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    provider_id?: boolean
    availability_isActive?: boolean
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    availability_id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    provider_id?: boolean
    availability_isActive?: boolean
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    availability_id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    provider_id?: boolean
    availability_isActive?: boolean
  }

  export type AvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"availability_id" | "dayOfWeek" | "startTime" | "endTime" | "provider_id" | "availability_isActive", ExtArgs["result"]["availability"]>
  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Availability$appointmentsArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    _count?: boolean | AvailabilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      serviceProvider: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      availability_id: number
      dayOfWeek: string
      startTime: string
      endTime: string
      provider_id: number
      availability_isActive: boolean
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `availability_id`
     * const availabilityWithAvailability_idOnly = await prisma.availability.findMany({ select: { availability_id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `availability_id`
     * const availabilityWithAvailability_idOnly = await prisma.availability.createManyAndReturn({
     *   select: { availability_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities and returns the data updated in the database.
     * @param {AvailabilityUpdateManyAndReturnArgs} args - Arguments to update many Availabilities.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Availabilities and only return the `availability_id`
     * const availabilityWithAvailability_idOnly = await prisma.availability.updateManyAndReturn({
     *   select: { availability_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Availability$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Availability$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceProvider<T extends ServiceProviderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetailsDefaultArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */
  interface AvailabilityFieldRefs {
    readonly availability_id: FieldRef<"Availability", 'Int'>
    readonly dayOfWeek: FieldRef<"Availability", 'String'>
    readonly startTime: FieldRef<"Availability", 'String'>
    readonly endTime: FieldRef<"Availability", 'String'>
    readonly provider_id: FieldRef<"Availability", 'Int'>
    readonly availability_isActive: FieldRef<"Availability", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
  }

  /**
   * Availability updateManyAndReturn
   */
  export type AvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to delete.
     */
    limit?: number
  }

  /**
   * Availability.appointments
   */
  export type Availability$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    appointment_id: number | null
    customer_id: number | null
    provider_id: number | null
    final_price: number | null
    availability_id: number | null
    service_id: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    appointment_id: number | null
    customer_id: number | null
    provider_id: number | null
    final_price: number | null
    availability_id: number | null
    service_id: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    appointment_id: number | null
    customer_id: number | null
    provider_id: number | null
    appointment_status: string | null
    scheduled_date: Date | null
    repairDescription: string | null
    created_at: Date | null
    final_price: number | null
    availability_id: number | null
    service_id: number | null
    cancellation_reason: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    appointment_id: number | null
    customer_id: number | null
    provider_id: number | null
    appointment_status: string | null
    scheduled_date: Date | null
    repairDescription: string | null
    created_at: Date | null
    final_price: number | null
    availability_id: number | null
    service_id: number | null
    cancellation_reason: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    appointment_id: number
    customer_id: number
    provider_id: number
    appointment_status: number
    scheduled_date: number
    repairDescription: number
    created_at: number
    final_price: number
    availability_id: number
    service_id: number
    cancellation_reason: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    appointment_id?: true
    customer_id?: true
    provider_id?: true
    final_price?: true
    availability_id?: true
    service_id?: true
  }

  export type AppointmentSumAggregateInputType = {
    appointment_id?: true
    customer_id?: true
    provider_id?: true
    final_price?: true
    availability_id?: true
    service_id?: true
  }

  export type AppointmentMinAggregateInputType = {
    appointment_id?: true
    customer_id?: true
    provider_id?: true
    appointment_status?: true
    scheduled_date?: true
    repairDescription?: true
    created_at?: true
    final_price?: true
    availability_id?: true
    service_id?: true
    cancellation_reason?: true
  }

  export type AppointmentMaxAggregateInputType = {
    appointment_id?: true
    customer_id?: true
    provider_id?: true
    appointment_status?: true
    scheduled_date?: true
    repairDescription?: true
    created_at?: true
    final_price?: true
    availability_id?: true
    service_id?: true
    cancellation_reason?: true
  }

  export type AppointmentCountAggregateInputType = {
    appointment_id?: true
    customer_id?: true
    provider_id?: true
    appointment_status?: true
    scheduled_date?: true
    repairDescription?: true
    created_at?: true
    final_price?: true
    availability_id?: true
    service_id?: true
    cancellation_reason?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    appointment_id: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date
    repairDescription: string | null
    created_at: Date
    final_price: number | null
    availability_id: number
    service_id: number
    cancellation_reason: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_id?: boolean
    customer_id?: boolean
    provider_id?: boolean
    appointment_status?: boolean
    scheduled_date?: boolean
    repairDescription?: boolean
    created_at?: boolean
    final_price?: boolean
    availability_id?: boolean
    service_id?: boolean
    cancellation_reason?: boolean
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
    appointment_rating?: boolean | Appointment$appointment_ratingArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_id?: boolean
    customer_id?: boolean
    provider_id?: boolean
    appointment_status?: boolean
    scheduled_date?: boolean
    repairDescription?: boolean
    created_at?: boolean
    final_price?: boolean
    availability_id?: boolean
    service_id?: boolean
    cancellation_reason?: boolean
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_id?: boolean
    customer_id?: boolean
    provider_id?: boolean
    appointment_status?: boolean
    scheduled_date?: boolean
    repairDescription?: boolean
    created_at?: boolean
    final_price?: boolean
    availability_id?: boolean
    service_id?: boolean
    cancellation_reason?: boolean
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    appointment_id?: boolean
    customer_id?: boolean
    provider_id?: boolean
    appointment_status?: boolean
    scheduled_date?: boolean
    repairDescription?: boolean
    created_at?: boolean
    final_price?: boolean
    availability_id?: boolean
    service_id?: boolean
    cancellation_reason?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appointment_id" | "customer_id" | "provider_id" | "appointment_status" | "scheduled_date" | "repairDescription" | "created_at" | "final_price" | "availability_id" | "service_id" | "cancellation_reason", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
    appointment_rating?: boolean | Appointment$appointment_ratingArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | AvailabilityDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    service?: boolean | ServiceListingDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      availability: Prisma.$AvailabilityPayload<ExtArgs>
      customer: Prisma.$UserPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
      service: Prisma.$ServiceListingPayload<ExtArgs>
      appointment_rating: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      appointment_id: number
      customer_id: number
      provider_id: number
      appointment_status: string
      scheduled_date: Date
      repairDescription: string | null
      created_at: Date
      final_price: number | null
      availability_id: number
      service_id: number
      cancellation_reason: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `appointment_id`
     * const appointmentWithAppointment_idOnly = await prisma.appointment.findMany({ select: { appointment_id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `appointment_id`
     * const appointmentWithAppointment_idOnly = await prisma.appointment.createManyAndReturn({
     *   select: { appointment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `appointment_id`
     * const appointmentWithAppointment_idOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { appointment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    availability<T extends AvailabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AvailabilityDefaultArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetailsDefaultArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceListingDefaultArgs<ExtArgs>>): Prisma__ServiceListingClient<$Result.GetResult<Prisma.$ServiceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment_rating<T extends Appointment$appointment_ratingArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$appointment_ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly appointment_id: FieldRef<"Appointment", 'Int'>
    readonly customer_id: FieldRef<"Appointment", 'Int'>
    readonly provider_id: FieldRef<"Appointment", 'Int'>
    readonly appointment_status: FieldRef<"Appointment", 'String'>
    readonly scheduled_date: FieldRef<"Appointment", 'DateTime'>
    readonly repairDescription: FieldRef<"Appointment", 'String'>
    readonly created_at: FieldRef<"Appointment", 'DateTime'>
    readonly final_price: FieldRef<"Appointment", 'Float'>
    readonly availability_id: FieldRef<"Appointment", 'Int'>
    readonly service_id: FieldRef<"Appointment", 'Int'>
    readonly cancellation_reason: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.appointment_rating
   */
  export type Appointment$appointment_ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    rating_value: number | null
    appointment_id: number | null
    user_id: number | null
    provider_id: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: number | null
    rating_value: number | null
    appointment_id: number | null
    user_id: number | null
    provider_id: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: number | null
    rating_value: number | null
    rating_comment: string | null
    appointment_id: number | null
    user_id: number | null
    provider_id: number | null
    rated_by: string | null
    created_at: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: number | null
    rating_value: number | null
    rating_comment: string | null
    appointment_id: number | null
    user_id: number | null
    provider_id: number | null
    rated_by: string | null
    created_at: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    rating_value: number
    rating_comment: number
    appointment_id: number
    user_id: number
    provider_id: number
    rated_by: number
    created_at: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    rating_value?: true
    appointment_id?: true
    user_id?: true
    provider_id?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    rating_value?: true
    appointment_id?: true
    user_id?: true
    provider_id?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    rating_value?: true
    rating_comment?: true
    appointment_id?: true
    user_id?: true
    provider_id?: true
    rated_by?: true
    created_at?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    rating_value?: true
    rating_comment?: true
    appointment_id?: true
    user_id?: true
    provider_id?: true
    rated_by?: true
    created_at?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    rating_value?: true
    rating_comment?: true
    appointment_id?: true
    user_id?: true
    provider_id?: true
    rated_by?: true
    created_at?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: number
    rating_value: number
    rating_comment: string | null
    appointment_id: number
    user_id: number
    provider_id: number
    rated_by: string
    created_at: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating_value?: boolean
    rating_comment?: boolean
    appointment_id?: boolean
    user_id?: boolean
    provider_id?: boolean
    rated_by?: boolean
    created_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating_value?: boolean
    rating_comment?: boolean
    appointment_id?: boolean
    user_id?: boolean
    provider_id?: boolean
    rated_by?: boolean
    created_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating_value?: boolean
    rating_comment?: boolean
    appointment_id?: boolean
    user_id?: boolean
    provider_id?: boolean
    rated_by?: boolean
    created_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    rating_value?: boolean
    rating_comment?: boolean
    appointment_id?: boolean
    user_id?: boolean
    provider_id?: boolean
    rated_by?: boolean
    created_at?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating_value" | "rating_comment" | "appointment_id" | "user_id" | "provider_id" | "rated_by" | "created_at", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDetailsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderDetailsPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rating_value: number
      rating_comment: string | null
      appointment_id: number
      user_id: number
      provider_id: number
      rated_by: string
      created_at: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDetailsDefaultArgs<ExtArgs>>): Prisma__ServiceProviderDetailsClient<$Result.GetResult<Prisma.$ServiceProviderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'Int'>
    readonly rating_value: FieldRef<"Rating", 'Int'>
    readonly rating_comment: FieldRef<"Rating", 'String'>
    readonly appointment_id: FieldRef<"Rating", 'Int'>
    readonly user_id: FieldRef<"Rating", 'Int'>
    readonly provider_id: FieldRef<"Rating", 'Int'>
    readonly rated_by: FieldRef<"Rating", 'String'>
    readonly created_at: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model OTPVerification
   */

  export type AggregateOTPVerification = {
    _count: OTPVerificationCountAggregateOutputType | null
    _avg: OTPVerificationAvgAggregateOutputType | null
    _sum: OTPVerificationSumAggregateOutputType | null
    _min: OTPVerificationMinAggregateOutputType | null
    _max: OTPVerificationMaxAggregateOutputType | null
  }

  export type OTPVerificationAvgAggregateOutputType = {
    id: number | null
  }

  export type OTPVerificationSumAggregateOutputType = {
    id: number | null
  }

  export type OTPVerificationMinAggregateOutputType = {
    id: number | null
    email: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type OTPVerificationMaxAggregateOutputType = {
    id: number | null
    email: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type OTPVerificationCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    expires_at: number
    created_at: number
    _all: number
  }


  export type OTPVerificationAvgAggregateInputType = {
    id?: true
  }

  export type OTPVerificationSumAggregateInputType = {
    id?: true
  }

  export type OTPVerificationMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expires_at?: true
    created_at?: true
  }

  export type OTPVerificationMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expires_at?: true
    created_at?: true
  }

  export type OTPVerificationCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expires_at?: true
    created_at?: true
    _all?: true
  }

  export type OTPVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPVerification to aggregate.
     */
    where?: OTPVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPVerifications to fetch.
     */
    orderBy?: OTPVerificationOrderByWithRelationInput | OTPVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPVerifications
    **/
    _count?: true | OTPVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPVerificationMaxAggregateInputType
  }

  export type GetOTPVerificationAggregateType<T extends OTPVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateOTPVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTPVerification[P]>
      : GetScalarType<T[P], AggregateOTPVerification[P]>
  }




  export type OTPVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPVerificationWhereInput
    orderBy?: OTPVerificationOrderByWithAggregationInput | OTPVerificationOrderByWithAggregationInput[]
    by: OTPVerificationScalarFieldEnum[] | OTPVerificationScalarFieldEnum
    having?: OTPVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPVerificationCountAggregateInputType | true
    _avg?: OTPVerificationAvgAggregateInputType
    _sum?: OTPVerificationSumAggregateInputType
    _min?: OTPVerificationMinAggregateInputType
    _max?: OTPVerificationMaxAggregateInputType
  }

  export type OTPVerificationGroupByOutputType = {
    id: number
    email: string
    otp: string
    expires_at: Date
    created_at: Date
    _count: OTPVerificationCountAggregateOutputType | null
    _avg: OTPVerificationAvgAggregateOutputType | null
    _sum: OTPVerificationSumAggregateOutputType | null
    _min: OTPVerificationMinAggregateOutputType | null
    _max: OTPVerificationMaxAggregateOutputType | null
  }

  type GetOTPVerificationGroupByPayload<T extends OTPVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], OTPVerificationGroupByOutputType[P]>
        }
      >
    >


  export type OTPVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["oTPVerification"]>

  export type OTPVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["oTPVerification"]>

  export type OTPVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["oTPVerification"]>

  export type OTPVerificationSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
  }

  export type OTPVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "expires_at" | "created_at", ExtArgs["result"]["oTPVerification"]>

  export type $OTPVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTPVerification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      otp: string
      expires_at: Date
      created_at: Date
    }, ExtArgs["result"]["oTPVerification"]>
    composites: {}
  }

  type OTPVerificationGetPayload<S extends boolean | null | undefined | OTPVerificationDefaultArgs> = $Result.GetResult<Prisma.$OTPVerificationPayload, S>

  type OTPVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPVerificationCountAggregateInputType | true
    }

  export interface OTPVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTPVerification'], meta: { name: 'OTPVerification' } }
    /**
     * Find zero or one OTPVerification that matches the filter.
     * @param {OTPVerificationFindUniqueArgs} args - Arguments to find a OTPVerification
     * @example
     * // Get one OTPVerification
     * const oTPVerification = await prisma.oTPVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPVerificationFindUniqueArgs>(args: SelectSubset<T, OTPVerificationFindUniqueArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTPVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPVerificationFindUniqueOrThrowArgs} args - Arguments to find a OTPVerification
     * @example
     * // Get one OTPVerification
     * const oTPVerification = await prisma.oTPVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTPVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationFindFirstArgs} args - Arguments to find a OTPVerification
     * @example
     * // Get one OTPVerification
     * const oTPVerification = await prisma.oTPVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPVerificationFindFirstArgs>(args?: SelectSubset<T, OTPVerificationFindFirstArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTPVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationFindFirstOrThrowArgs} args - Arguments to find a OTPVerification
     * @example
     * // Get one OTPVerification
     * const oTPVerification = await prisma.oTPVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPVerifications
     * const oTPVerifications = await prisma.oTPVerification.findMany()
     * 
     * // Get first 10 OTPVerifications
     * const oTPVerifications = await prisma.oTPVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPVerificationWithIdOnly = await prisma.oTPVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPVerificationFindManyArgs>(args?: SelectSubset<T, OTPVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTPVerification.
     * @param {OTPVerificationCreateArgs} args - Arguments to create a OTPVerification.
     * @example
     * // Create one OTPVerification
     * const OTPVerification = await prisma.oTPVerification.create({
     *   data: {
     *     // ... data to create a OTPVerification
     *   }
     * })
     * 
     */
    create<T extends OTPVerificationCreateArgs>(args: SelectSubset<T, OTPVerificationCreateArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPVerifications.
     * @param {OTPVerificationCreateManyArgs} args - Arguments to create many OTPVerifications.
     * @example
     * // Create many OTPVerifications
     * const oTPVerification = await prisma.oTPVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPVerificationCreateManyArgs>(args?: SelectSubset<T, OTPVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPVerifications and returns the data saved in the database.
     * @param {OTPVerificationCreateManyAndReturnArgs} args - Arguments to create many OTPVerifications.
     * @example
     * // Create many OTPVerifications
     * const oTPVerification = await prisma.oTPVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPVerifications and only return the `id`
     * const oTPVerificationWithIdOnly = await prisma.oTPVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTPVerification.
     * @param {OTPVerificationDeleteArgs} args - Arguments to delete one OTPVerification.
     * @example
     * // Delete one OTPVerification
     * const OTPVerification = await prisma.oTPVerification.delete({
     *   where: {
     *     // ... filter to delete one OTPVerification
     *   }
     * })
     * 
     */
    delete<T extends OTPVerificationDeleteArgs>(args: SelectSubset<T, OTPVerificationDeleteArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTPVerification.
     * @param {OTPVerificationUpdateArgs} args - Arguments to update one OTPVerification.
     * @example
     * // Update one OTPVerification
     * const oTPVerification = await prisma.oTPVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPVerificationUpdateArgs>(args: SelectSubset<T, OTPVerificationUpdateArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPVerifications.
     * @param {OTPVerificationDeleteManyArgs} args - Arguments to filter OTPVerifications to delete.
     * @example
     * // Delete a few OTPVerifications
     * const { count } = await prisma.oTPVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPVerificationDeleteManyArgs>(args?: SelectSubset<T, OTPVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPVerifications
     * const oTPVerification = await prisma.oTPVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPVerificationUpdateManyArgs>(args: SelectSubset<T, OTPVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPVerifications and returns the data updated in the database.
     * @param {OTPVerificationUpdateManyAndReturnArgs} args - Arguments to update many OTPVerifications.
     * @example
     * // Update many OTPVerifications
     * const oTPVerification = await prisma.oTPVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPVerifications and only return the `id`
     * const oTPVerificationWithIdOnly = await prisma.oTPVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTPVerification.
     * @param {OTPVerificationUpsertArgs} args - Arguments to update or create a OTPVerification.
     * @example
     * // Update or create a OTPVerification
     * const oTPVerification = await prisma.oTPVerification.upsert({
     *   create: {
     *     // ... data to create a OTPVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTPVerification we want to update
     *   }
     * })
     */
    upsert<T extends OTPVerificationUpsertArgs>(args: SelectSubset<T, OTPVerificationUpsertArgs<ExtArgs>>): Prisma__OTPVerificationClient<$Result.GetResult<Prisma.$OTPVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationCountArgs} args - Arguments to filter OTPVerifications to count.
     * @example
     * // Count the number of OTPVerifications
     * const count = await prisma.oTPVerification.count({
     *   where: {
     *     // ... the filter for the OTPVerifications we want to count
     *   }
     * })
    **/
    count<T extends OTPVerificationCountArgs>(
      args?: Subset<T, OTPVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTPVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPVerificationAggregateArgs>(args: Subset<T, OTPVerificationAggregateArgs>): Prisma.PrismaPromise<GetOTPVerificationAggregateType<T>>

    /**
     * Group by OTPVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPVerificationGroupByArgs['orderBy'] }
        : { orderBy?: OTPVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTPVerification model
   */
  readonly fields: OTPVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTPVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTPVerification model
   */
  interface OTPVerificationFieldRefs {
    readonly id: FieldRef<"OTPVerification", 'Int'>
    readonly email: FieldRef<"OTPVerification", 'String'>
    readonly otp: FieldRef<"OTPVerification", 'String'>
    readonly expires_at: FieldRef<"OTPVerification", 'DateTime'>
    readonly created_at: FieldRef<"OTPVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTPVerification findUnique
   */
  export type OTPVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter, which OTPVerification to fetch.
     */
    where: OTPVerificationWhereUniqueInput
  }

  /**
   * OTPVerification findUniqueOrThrow
   */
  export type OTPVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter, which OTPVerification to fetch.
     */
    where: OTPVerificationWhereUniqueInput
  }

  /**
   * OTPVerification findFirst
   */
  export type OTPVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter, which OTPVerification to fetch.
     */
    where?: OTPVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPVerifications to fetch.
     */
    orderBy?: OTPVerificationOrderByWithRelationInput | OTPVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPVerifications.
     */
    cursor?: OTPVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPVerifications.
     */
    distinct?: OTPVerificationScalarFieldEnum | OTPVerificationScalarFieldEnum[]
  }

  /**
   * OTPVerification findFirstOrThrow
   */
  export type OTPVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter, which OTPVerification to fetch.
     */
    where?: OTPVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPVerifications to fetch.
     */
    orderBy?: OTPVerificationOrderByWithRelationInput | OTPVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPVerifications.
     */
    cursor?: OTPVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPVerifications.
     */
    distinct?: OTPVerificationScalarFieldEnum | OTPVerificationScalarFieldEnum[]
  }

  /**
   * OTPVerification findMany
   */
  export type OTPVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter, which OTPVerifications to fetch.
     */
    where?: OTPVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPVerifications to fetch.
     */
    orderBy?: OTPVerificationOrderByWithRelationInput | OTPVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPVerifications.
     */
    cursor?: OTPVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPVerifications.
     */
    skip?: number
    distinct?: OTPVerificationScalarFieldEnum | OTPVerificationScalarFieldEnum[]
  }

  /**
   * OTPVerification create
   */
  export type OTPVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a OTPVerification.
     */
    data: XOR<OTPVerificationCreateInput, OTPVerificationUncheckedCreateInput>
  }

  /**
   * OTPVerification createMany
   */
  export type OTPVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPVerifications.
     */
    data: OTPVerificationCreateManyInput | OTPVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTPVerification createManyAndReturn
   */
  export type OTPVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many OTPVerifications.
     */
    data: OTPVerificationCreateManyInput | OTPVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTPVerification update
   */
  export type OTPVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a OTPVerification.
     */
    data: XOR<OTPVerificationUpdateInput, OTPVerificationUncheckedUpdateInput>
    /**
     * Choose, which OTPVerification to update.
     */
    where: OTPVerificationWhereUniqueInput
  }

  /**
   * OTPVerification updateMany
   */
  export type OTPVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPVerifications.
     */
    data: XOR<OTPVerificationUpdateManyMutationInput, OTPVerificationUncheckedUpdateManyInput>
    /**
     * Filter which OTPVerifications to update
     */
    where?: OTPVerificationWhereInput
    /**
     * Limit how many OTPVerifications to update.
     */
    limit?: number
  }

  /**
   * OTPVerification updateManyAndReturn
   */
  export type OTPVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * The data used to update OTPVerifications.
     */
    data: XOR<OTPVerificationUpdateManyMutationInput, OTPVerificationUncheckedUpdateManyInput>
    /**
     * Filter which OTPVerifications to update
     */
    where?: OTPVerificationWhereInput
    /**
     * Limit how many OTPVerifications to update.
     */
    limit?: number
  }

  /**
   * OTPVerification upsert
   */
  export type OTPVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the OTPVerification to update in case it exists.
     */
    where: OTPVerificationWhereUniqueInput
    /**
     * In case the OTPVerification found by the `where` argument doesn't exist, create a new OTPVerification with this data.
     */
    create: XOR<OTPVerificationCreateInput, OTPVerificationUncheckedCreateInput>
    /**
     * In case the OTPVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPVerificationUpdateInput, OTPVerificationUncheckedUpdateInput>
  }

  /**
   * OTPVerification delete
   */
  export type OTPVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
    /**
     * Filter which OTPVerification to delete.
     */
    where: OTPVerificationWhereUniqueInput
  }

  /**
   * OTPVerification deleteMany
   */
  export type OTPVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPVerifications to delete
     */
    where?: OTPVerificationWhereInput
    /**
     * Limit how many OTPVerifications to delete.
     */
    limit?: number
  }

  /**
   * OTPVerification without action
   */
  export type OTPVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTPVerification
     */
    select?: OTPVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTPVerification
     */
    omit?: OTPVerificationOmit<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    admin_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    admin_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    admin_id: number | null
    admin_username: string | null
    admin_email: string | null
    admin_password: string | null
    admin_name: string | null
    admin_role: string | null
    created_at: Date | null
    last_login: Date | null
    is_active: boolean | null
  }

  export type AdminMaxAggregateOutputType = {
    admin_id: number | null
    admin_username: string | null
    admin_email: string | null
    admin_password: string | null
    admin_name: string | null
    admin_role: string | null
    created_at: Date | null
    last_login: Date | null
    is_active: boolean | null
  }

  export type AdminCountAggregateOutputType = {
    admin_id: number
    admin_username: number
    admin_email: number
    admin_password: number
    admin_name: number
    admin_role: number
    created_at: number
    last_login: number
    is_active: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    admin_id?: true
  }

  export type AdminSumAggregateInputType = {
    admin_id?: true
  }

  export type AdminMinAggregateInputType = {
    admin_id?: true
    admin_username?: true
    admin_email?: true
    admin_password?: true
    admin_name?: true
    admin_role?: true
    created_at?: true
    last_login?: true
    is_active?: true
  }

  export type AdminMaxAggregateInputType = {
    admin_id?: true
    admin_username?: true
    admin_email?: true
    admin_password?: true
    admin_name?: true
    admin_role?: true
    created_at?: true
    last_login?: true
    is_active?: true
  }

  export type AdminCountAggregateInputType = {
    admin_id?: true
    admin_username?: true
    admin_email?: true
    admin_password?: true
    admin_name?: true
    admin_role?: true
    created_at?: true
    last_login?: true
    is_active?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    admin_id: number
    admin_username: string
    admin_email: string
    admin_password: string
    admin_name: string
    admin_role: string
    created_at: Date
    last_login: Date | null
    is_active: boolean
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    admin_username?: boolean
    admin_email?: boolean
    admin_password?: boolean
    admin_name?: boolean
    admin_role?: boolean
    created_at?: boolean
    last_login?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    admin_username?: boolean
    admin_email?: boolean
    admin_password?: boolean
    admin_name?: boolean
    admin_role?: boolean
    created_at?: boolean
    last_login?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    admin_username?: boolean
    admin_email?: boolean
    admin_password?: boolean
    admin_name?: boolean
    admin_role?: boolean
    created_at?: boolean
    last_login?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    admin_id?: boolean
    admin_username?: boolean
    admin_email?: boolean
    admin_password?: boolean
    admin_name?: boolean
    admin_role?: boolean
    created_at?: boolean
    last_login?: boolean
    is_active?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"admin_id" | "admin_username" | "admin_email" | "admin_password" | "admin_name" | "admin_role" | "created_at" | "last_login" | "is_active", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      admin_id: number
      admin_username: string
      admin_email: string
      admin_password: string
      admin_name: string
      admin_role: string
      created_at: Date
      last_login: Date | null
      is_active: boolean
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.findMany({ select: { admin_id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.createManyAndReturn({
     *   select: { admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.updateManyAndReturn({
     *   select: { admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly admin_id: FieldRef<"Admin", 'Int'>
    readonly admin_username: FieldRef<"Admin", 'String'>
    readonly admin_email: FieldRef<"Admin", 'String'>
    readonly admin_password: FieldRef<"Admin", 'String'>
    readonly admin_name: FieldRef<"Admin", 'String'>
    readonly admin_role: FieldRef<"Admin", 'String'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
    readonly last_login: FieldRef<"Admin", 'DateTime'>
    readonly is_active: FieldRef<"Admin", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    profile_photo: 'profile_photo',
    valid_id: 'valid_id',
    user_location: 'user_location',
    created_at: 'created_at',
    is_verified: 'is_verified',
    password: 'password',
    userName: 'userName',
    is_activated: 'is_activated',
    birthday: 'birthday',
    exact_location: 'exact_location'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ServiceProviderDetailsScalarFieldEnum: {
    provider_id: 'provider_id',
    provider_first_name: 'provider_first_name',
    provider_last_name: 'provider_last_name',
    provider_email: 'provider_email',
    provider_phone_number: 'provider_phone_number',
    provider_profile_photo: 'provider_profile_photo',
    provider_valid_id: 'provider_valid_id',
    provider_isVerified: 'provider_isVerified',
    created_at: 'created_at',
    provider_rating: 'provider_rating',
    provider_location: 'provider_location',
    provider_uli: 'provider_uli',
    provider_password: 'provider_password',
    provider_userName: 'provider_userName',
    provider_isActivated: 'provider_isActivated',
    provider_birthday: 'provider_birthday',
    provider_exact_location: 'provider_exact_location'
  };

  export type ServiceProviderDetailsScalarFieldEnum = (typeof ServiceProviderDetailsScalarFieldEnum)[keyof typeof ServiceProviderDetailsScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    certificate_id: 'certificate_id',
    certificate_name: 'certificate_name',
    certificate_file_path: 'certificate_file_path',
    expiry_date: 'expiry_date',
    provider_id: 'provider_id',
    certificate_number: 'certificate_number',
    certificate_status: 'certificate_status',
    created_at: 'created_at'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const ServiceListingScalarFieldEnum: {
    service_id: 'service_id',
    service_title: 'service_title',
    service_description: 'service_description',
    service_startingprice: 'service_startingprice',
    provider_id: 'provider_id',
    servicelisting_isActive: 'servicelisting_isActive',
    service_picture: 'service_picture'
  };

  export type ServiceListingScalarFieldEnum = (typeof ServiceListingScalarFieldEnum)[keyof typeof ServiceListingScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    category_id: 'category_id',
    category_name: 'category_name'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const SpecificServiceScalarFieldEnum: {
    specific_service_id: 'specific_service_id',
    specific_service_title: 'specific_service_title',
    specific_service_description: 'specific_service_description',
    service_id: 'service_id',
    category_id: 'category_id'
  };

  export type SpecificServiceScalarFieldEnum = (typeof SpecificServiceScalarFieldEnum)[keyof typeof SpecificServiceScalarFieldEnum]


  export const CoveredServiceScalarFieldEnum: {
    covered_service_id: 'covered_service_id',
    specific_service_id: 'specific_service_id',
    certificate_id: 'certificate_id'
  };

  export type CoveredServiceScalarFieldEnum = (typeof CoveredServiceScalarFieldEnum)[keyof typeof CoveredServiceScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    availability_id: 'availability_id',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    provider_id: 'provider_id',
    availability_isActive: 'availability_isActive'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    appointment_id: 'appointment_id',
    customer_id: 'customer_id',
    provider_id: 'provider_id',
    appointment_status: 'appointment_status',
    scheduled_date: 'scheduled_date',
    repairDescription: 'repairDescription',
    created_at: 'created_at',
    final_price: 'final_price',
    availability_id: 'availability_id',
    service_id: 'service_id',
    cancellation_reason: 'cancellation_reason'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    rating_value: 'rating_value',
    rating_comment: 'rating_comment',
    appointment_id: 'appointment_id',
    user_id: 'user_id',
    provider_id: 'provider_id',
    rated_by: 'rated_by',
    created_at: 'created_at'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const OTPVerificationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    expires_at: 'expires_at',
    created_at: 'created_at'
  };

  export type OTPVerificationScalarFieldEnum = (typeof OTPVerificationScalarFieldEnum)[keyof typeof OTPVerificationScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    admin_id: 'admin_id',
    admin_username: 'admin_username',
    admin_email: 'admin_email',
    admin_password: 'admin_password',
    admin_name: 'admin_name',
    admin_role: 'admin_role',
    created_at: 'created_at',
    last_login: 'last_login',
    is_active: 'is_active'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_id?: IntFilter<"User"> | number
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    profile_photo?: StringNullableFilter<"User"> | string | null
    valid_id?: StringNullableFilter<"User"> | string | null
    user_location?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    is_verified?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    is_activated?: BoolFilter<"User"> | boolean
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    exact_location?: StringNullableFilter<"User"> | string | null
    user_appointments?: AppointmentListRelationFilter
    user_rating?: RatingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    profile_photo?: SortOrderInput | SortOrder
    valid_id?: SortOrderInput | SortOrder
    user_location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    password?: SortOrder
    userName?: SortOrder
    is_activated?: SortOrder
    birthday?: SortOrderInput | SortOrder
    exact_location?: SortOrderInput | SortOrder
    user_appointments?: AppointmentOrderByRelationAggregateInput
    user_rating?: RatingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    phone_number?: string
    userName?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    profile_photo?: StringNullableFilter<"User"> | string | null
    valid_id?: StringNullableFilter<"User"> | string | null
    user_location?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    is_verified?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    is_activated?: BoolFilter<"User"> | boolean
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    exact_location?: StringNullableFilter<"User"> | string | null
    user_appointments?: AppointmentListRelationFilter
    user_rating?: RatingListRelationFilter
  }, "user_id" | "email" | "phone_number" | "userName">

  export type UserOrderByWithAggregationInput = {
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    profile_photo?: SortOrderInput | SortOrder
    valid_id?: SortOrderInput | SortOrder
    user_location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    password?: SortOrder
    userName?: SortOrder
    is_activated?: SortOrder
    birthday?: SortOrderInput | SortOrder
    exact_location?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"User"> | number
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringWithAggregatesFilter<"User"> | string
    profile_photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    valid_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    user_location?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    is_verified?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringWithAggregatesFilter<"User"> | string
    userName?: StringWithAggregatesFilter<"User"> | string
    is_activated?: BoolWithAggregatesFilter<"User"> | boolean
    birthday?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    exact_location?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ServiceProviderDetailsWhereInput = {
    AND?: ServiceProviderDetailsWhereInput | ServiceProviderDetailsWhereInput[]
    OR?: ServiceProviderDetailsWhereInput[]
    NOT?: ServiceProviderDetailsWhereInput | ServiceProviderDetailsWhereInput[]
    provider_id?: IntFilter<"ServiceProviderDetails"> | number
    provider_first_name?: StringFilter<"ServiceProviderDetails"> | string
    provider_last_name?: StringFilter<"ServiceProviderDetails"> | string
    provider_email?: StringFilter<"ServiceProviderDetails"> | string
    provider_phone_number?: StringFilter<"ServiceProviderDetails"> | string
    provider_profile_photo?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_valid_id?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_isVerified?: BoolFilter<"ServiceProviderDetails"> | boolean
    created_at?: DateTimeFilter<"ServiceProviderDetails"> | Date | string
    provider_rating?: FloatFilter<"ServiceProviderDetails"> | number
    provider_location?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_uli?: StringFilter<"ServiceProviderDetails"> | string
    provider_password?: StringFilter<"ServiceProviderDetails"> | string
    provider_userName?: StringFilter<"ServiceProviderDetails"> | string
    provider_isActivated?: BoolFilter<"ServiceProviderDetails"> | boolean
    provider_birthday?: DateTimeNullableFilter<"ServiceProviderDetails"> | Date | string | null
    provider_exact_location?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_appointments?: AppointmentListRelationFilter
    provider_availability?: AvailabilityListRelationFilter
    provider_certificates?: CertificateListRelationFilter
    provider_ratings?: RatingListRelationFilter
    provider_services?: ServiceListingListRelationFilter
  }

  export type ServiceProviderDetailsOrderByWithRelationInput = {
    provider_id?: SortOrder
    provider_first_name?: SortOrder
    provider_last_name?: SortOrder
    provider_email?: SortOrder
    provider_phone_number?: SortOrder
    provider_profile_photo?: SortOrderInput | SortOrder
    provider_valid_id?: SortOrderInput | SortOrder
    provider_isVerified?: SortOrder
    created_at?: SortOrder
    provider_rating?: SortOrder
    provider_location?: SortOrderInput | SortOrder
    provider_uli?: SortOrder
    provider_password?: SortOrder
    provider_userName?: SortOrder
    provider_isActivated?: SortOrder
    provider_birthday?: SortOrderInput | SortOrder
    provider_exact_location?: SortOrderInput | SortOrder
    provider_appointments?: AppointmentOrderByRelationAggregateInput
    provider_availability?: AvailabilityOrderByRelationAggregateInput
    provider_certificates?: CertificateOrderByRelationAggregateInput
    provider_ratings?: RatingOrderByRelationAggregateInput
    provider_services?: ServiceListingOrderByRelationAggregateInput
  }

  export type ServiceProviderDetailsWhereUniqueInput = Prisma.AtLeast<{
    provider_id?: number
    provider_email?: string
    provider_phone_number?: string
    provider_uli?: string
    provider_userName?: string
    AND?: ServiceProviderDetailsWhereInput | ServiceProviderDetailsWhereInput[]
    OR?: ServiceProviderDetailsWhereInput[]
    NOT?: ServiceProviderDetailsWhereInput | ServiceProviderDetailsWhereInput[]
    provider_first_name?: StringFilter<"ServiceProviderDetails"> | string
    provider_last_name?: StringFilter<"ServiceProviderDetails"> | string
    provider_profile_photo?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_valid_id?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_isVerified?: BoolFilter<"ServiceProviderDetails"> | boolean
    created_at?: DateTimeFilter<"ServiceProviderDetails"> | Date | string
    provider_rating?: FloatFilter<"ServiceProviderDetails"> | number
    provider_location?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_password?: StringFilter<"ServiceProviderDetails"> | string
    provider_isActivated?: BoolFilter<"ServiceProviderDetails"> | boolean
    provider_birthday?: DateTimeNullableFilter<"ServiceProviderDetails"> | Date | string | null
    provider_exact_location?: StringNullableFilter<"ServiceProviderDetails"> | string | null
    provider_appointments?: AppointmentListRelationFilter
    provider_availability?: AvailabilityListRelationFilter
    provider_certificates?: CertificateListRelationFilter
    provider_ratings?: RatingListRelationFilter
    provider_services?: ServiceListingListRelationFilter
  }, "provider_id" | "provider_email" | "provider_phone_number" | "provider_uli" | "provider_userName">

  export type ServiceProviderDetailsOrderByWithAggregationInput = {
    provider_id?: SortOrder
    provider_first_name?: SortOrder
    provider_last_name?: SortOrder
    provider_email?: SortOrder
    provider_phone_number?: SortOrder
    provider_profile_photo?: SortOrderInput | SortOrder
    provider_valid_id?: SortOrderInput | SortOrder
    provider_isVerified?: SortOrder
    created_at?: SortOrder
    provider_rating?: SortOrder
    provider_location?: SortOrderInput | SortOrder
    provider_uli?: SortOrder
    provider_password?: SortOrder
    provider_userName?: SortOrder
    provider_isActivated?: SortOrder
    provider_birthday?: SortOrderInput | SortOrder
    provider_exact_location?: SortOrderInput | SortOrder
    _count?: ServiceProviderDetailsCountOrderByAggregateInput
    _avg?: ServiceProviderDetailsAvgOrderByAggregateInput
    _max?: ServiceProviderDetailsMaxOrderByAggregateInput
    _min?: ServiceProviderDetailsMinOrderByAggregateInput
    _sum?: ServiceProviderDetailsSumOrderByAggregateInput
  }

  export type ServiceProviderDetailsScalarWhereWithAggregatesInput = {
    AND?: ServiceProviderDetailsScalarWhereWithAggregatesInput | ServiceProviderDetailsScalarWhereWithAggregatesInput[]
    OR?: ServiceProviderDetailsScalarWhereWithAggregatesInput[]
    NOT?: ServiceProviderDetailsScalarWhereWithAggregatesInput | ServiceProviderDetailsScalarWhereWithAggregatesInput[]
    provider_id?: IntWithAggregatesFilter<"ServiceProviderDetails"> | number
    provider_first_name?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_last_name?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_email?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_phone_number?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_profile_photo?: StringNullableWithAggregatesFilter<"ServiceProviderDetails"> | string | null
    provider_valid_id?: StringNullableWithAggregatesFilter<"ServiceProviderDetails"> | string | null
    provider_isVerified?: BoolWithAggregatesFilter<"ServiceProviderDetails"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ServiceProviderDetails"> | Date | string
    provider_rating?: FloatWithAggregatesFilter<"ServiceProviderDetails"> | number
    provider_location?: StringNullableWithAggregatesFilter<"ServiceProviderDetails"> | string | null
    provider_uli?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_password?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_userName?: StringWithAggregatesFilter<"ServiceProviderDetails"> | string
    provider_isActivated?: BoolWithAggregatesFilter<"ServiceProviderDetails"> | boolean
    provider_birthday?: DateTimeNullableWithAggregatesFilter<"ServiceProviderDetails"> | Date | string | null
    provider_exact_location?: StringNullableWithAggregatesFilter<"ServiceProviderDetails"> | string | null
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    certificate_id?: IntFilter<"Certificate"> | number
    certificate_name?: StringFilter<"Certificate"> | string
    certificate_file_path?: StringFilter<"Certificate"> | string
    expiry_date?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    provider_id?: IntFilter<"Certificate"> | number
    certificate_number?: StringFilter<"Certificate"> | string
    certificate_status?: StringFilter<"Certificate"> | string
    created_at?: DateTimeFilter<"Certificate"> | Date | string
    provider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    CoveredService?: CoveredServiceListRelationFilter
  }

  export type CertificateOrderByWithRelationInput = {
    certificate_id?: SortOrder
    certificate_name?: SortOrder
    certificate_file_path?: SortOrder
    expiry_date?: SortOrderInput | SortOrder
    provider_id?: SortOrder
    certificate_number?: SortOrder
    certificate_status?: SortOrder
    created_at?: SortOrder
    provider?: ServiceProviderDetailsOrderByWithRelationInput
    CoveredService?: CoveredServiceOrderByRelationAggregateInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    certificate_id?: number
    certificate_number?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    certificate_name?: StringFilter<"Certificate"> | string
    certificate_file_path?: StringFilter<"Certificate"> | string
    expiry_date?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    provider_id?: IntFilter<"Certificate"> | number
    certificate_status?: StringFilter<"Certificate"> | string
    created_at?: DateTimeFilter<"Certificate"> | Date | string
    provider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    CoveredService?: CoveredServiceListRelationFilter
  }, "certificate_id" | "certificate_number">

  export type CertificateOrderByWithAggregationInput = {
    certificate_id?: SortOrder
    certificate_name?: SortOrder
    certificate_file_path?: SortOrder
    expiry_date?: SortOrderInput | SortOrder
    provider_id?: SortOrder
    certificate_number?: SortOrder
    certificate_status?: SortOrder
    created_at?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    certificate_id?: IntWithAggregatesFilter<"Certificate"> | number
    certificate_name?: StringWithAggregatesFilter<"Certificate"> | string
    certificate_file_path?: StringWithAggregatesFilter<"Certificate"> | string
    expiry_date?: DateTimeNullableWithAggregatesFilter<"Certificate"> | Date | string | null
    provider_id?: IntWithAggregatesFilter<"Certificate"> | number
    certificate_number?: StringWithAggregatesFilter<"Certificate"> | string
    certificate_status?: StringWithAggregatesFilter<"Certificate"> | string
    created_at?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type ServiceListingWhereInput = {
    AND?: ServiceListingWhereInput | ServiceListingWhereInput[]
    OR?: ServiceListingWhereInput[]
    NOT?: ServiceListingWhereInput | ServiceListingWhereInput[]
    service_id?: IntFilter<"ServiceListing"> | number
    service_title?: StringFilter<"ServiceListing"> | string
    service_description?: StringFilter<"ServiceListing"> | string
    service_startingprice?: FloatFilter<"ServiceListing"> | number
    provider_id?: IntFilter<"ServiceListing"> | number
    servicelisting_isActive?: BoolFilter<"ServiceListing"> | boolean
    service_picture?: StringNullableFilter<"ServiceListing"> | string | null
    appointments?: AppointmentListRelationFilter
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    specific_services?: SpecificServiceListRelationFilter
  }

  export type ServiceListingOrderByWithRelationInput = {
    service_id?: SortOrder
    service_title?: SortOrder
    service_description?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
    servicelisting_isActive?: SortOrder
    service_picture?: SortOrderInput | SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    serviceProvider?: ServiceProviderDetailsOrderByWithRelationInput
    specific_services?: SpecificServiceOrderByRelationAggregateInput
  }

  export type ServiceListingWhereUniqueInput = Prisma.AtLeast<{
    service_id?: number
    AND?: ServiceListingWhereInput | ServiceListingWhereInput[]
    OR?: ServiceListingWhereInput[]
    NOT?: ServiceListingWhereInput | ServiceListingWhereInput[]
    service_title?: StringFilter<"ServiceListing"> | string
    service_description?: StringFilter<"ServiceListing"> | string
    service_startingprice?: FloatFilter<"ServiceListing"> | number
    provider_id?: IntFilter<"ServiceListing"> | number
    servicelisting_isActive?: BoolFilter<"ServiceListing"> | boolean
    service_picture?: StringNullableFilter<"ServiceListing"> | string | null
    appointments?: AppointmentListRelationFilter
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    specific_services?: SpecificServiceListRelationFilter
  }, "service_id">

  export type ServiceListingOrderByWithAggregationInput = {
    service_id?: SortOrder
    service_title?: SortOrder
    service_description?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
    servicelisting_isActive?: SortOrder
    service_picture?: SortOrderInput | SortOrder
    _count?: ServiceListingCountOrderByAggregateInput
    _avg?: ServiceListingAvgOrderByAggregateInput
    _max?: ServiceListingMaxOrderByAggregateInput
    _min?: ServiceListingMinOrderByAggregateInput
    _sum?: ServiceListingSumOrderByAggregateInput
  }

  export type ServiceListingScalarWhereWithAggregatesInput = {
    AND?: ServiceListingScalarWhereWithAggregatesInput | ServiceListingScalarWhereWithAggregatesInput[]
    OR?: ServiceListingScalarWhereWithAggregatesInput[]
    NOT?: ServiceListingScalarWhereWithAggregatesInput | ServiceListingScalarWhereWithAggregatesInput[]
    service_id?: IntWithAggregatesFilter<"ServiceListing"> | number
    service_title?: StringWithAggregatesFilter<"ServiceListing"> | string
    service_description?: StringWithAggregatesFilter<"ServiceListing"> | string
    service_startingprice?: FloatWithAggregatesFilter<"ServiceListing"> | number
    provider_id?: IntWithAggregatesFilter<"ServiceListing"> | number
    servicelisting_isActive?: BoolWithAggregatesFilter<"ServiceListing"> | boolean
    service_picture?: StringNullableWithAggregatesFilter<"ServiceListing"> | string | null
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    category_id?: IntFilter<"ServiceCategory"> | number
    category_name?: StringFilter<"ServiceCategory"> | string
    specific_services?: SpecificServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    specific_services?: SpecificServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    category_id?: number
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    category_name?: StringFilter<"ServiceCategory"> | string
    specific_services?: SpecificServiceListRelationFilter
  }, "category_id">

  export type ServiceCategoryOrderByWithAggregationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _avg?: ServiceCategoryAvgOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
    _sum?: ServiceCategorySumOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    category_id?: IntWithAggregatesFilter<"ServiceCategory"> | number
    category_name?: StringWithAggregatesFilter<"ServiceCategory"> | string
  }

  export type SpecificServiceWhereInput = {
    AND?: SpecificServiceWhereInput | SpecificServiceWhereInput[]
    OR?: SpecificServiceWhereInput[]
    NOT?: SpecificServiceWhereInput | SpecificServiceWhereInput[]
    specific_service_id?: IntFilter<"SpecificService"> | number
    specific_service_title?: StringFilter<"SpecificService"> | string
    specific_service_description?: StringFilter<"SpecificService"> | string
    service_id?: IntFilter<"SpecificService"> | number
    category_id?: IntFilter<"SpecificService"> | number
    covered_by_certificates?: CoveredServiceListRelationFilter
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    serviceListing?: XOR<ServiceListingScalarRelationFilter, ServiceListingWhereInput>
  }

  export type SpecificServiceOrderByWithRelationInput = {
    specific_service_id?: SortOrder
    specific_service_title?: SortOrder
    specific_service_description?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
    covered_by_certificates?: CoveredServiceOrderByRelationAggregateInput
    category?: ServiceCategoryOrderByWithRelationInput
    serviceListing?: ServiceListingOrderByWithRelationInput
  }

  export type SpecificServiceWhereUniqueInput = Prisma.AtLeast<{
    specific_service_id?: number
    AND?: SpecificServiceWhereInput | SpecificServiceWhereInput[]
    OR?: SpecificServiceWhereInput[]
    NOT?: SpecificServiceWhereInput | SpecificServiceWhereInput[]
    specific_service_title?: StringFilter<"SpecificService"> | string
    specific_service_description?: StringFilter<"SpecificService"> | string
    service_id?: IntFilter<"SpecificService"> | number
    category_id?: IntFilter<"SpecificService"> | number
    covered_by_certificates?: CoveredServiceListRelationFilter
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    serviceListing?: XOR<ServiceListingScalarRelationFilter, ServiceListingWhereInput>
  }, "specific_service_id">

  export type SpecificServiceOrderByWithAggregationInput = {
    specific_service_id?: SortOrder
    specific_service_title?: SortOrder
    specific_service_description?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
    _count?: SpecificServiceCountOrderByAggregateInput
    _avg?: SpecificServiceAvgOrderByAggregateInput
    _max?: SpecificServiceMaxOrderByAggregateInput
    _min?: SpecificServiceMinOrderByAggregateInput
    _sum?: SpecificServiceSumOrderByAggregateInput
  }

  export type SpecificServiceScalarWhereWithAggregatesInput = {
    AND?: SpecificServiceScalarWhereWithAggregatesInput | SpecificServiceScalarWhereWithAggregatesInput[]
    OR?: SpecificServiceScalarWhereWithAggregatesInput[]
    NOT?: SpecificServiceScalarWhereWithAggregatesInput | SpecificServiceScalarWhereWithAggregatesInput[]
    specific_service_id?: IntWithAggregatesFilter<"SpecificService"> | number
    specific_service_title?: StringWithAggregatesFilter<"SpecificService"> | string
    specific_service_description?: StringWithAggregatesFilter<"SpecificService"> | string
    service_id?: IntWithAggregatesFilter<"SpecificService"> | number
    category_id?: IntWithAggregatesFilter<"SpecificService"> | number
  }

  export type CoveredServiceWhereInput = {
    AND?: CoveredServiceWhereInput | CoveredServiceWhereInput[]
    OR?: CoveredServiceWhereInput[]
    NOT?: CoveredServiceWhereInput | CoveredServiceWhereInput[]
    covered_service_id?: IntFilter<"CoveredService"> | number
    specific_service_id?: IntFilter<"CoveredService"> | number
    certificate_id?: IntFilter<"CoveredService"> | number
    certificate?: XOR<CertificateScalarRelationFilter, CertificateWhereInput>
    specific_service?: XOR<SpecificServiceScalarRelationFilter, SpecificServiceWhereInput>
  }

  export type CoveredServiceOrderByWithRelationInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
    certificate?: CertificateOrderByWithRelationInput
    specific_service?: SpecificServiceOrderByWithRelationInput
  }

  export type CoveredServiceWhereUniqueInput = Prisma.AtLeast<{
    covered_service_id?: number
    AND?: CoveredServiceWhereInput | CoveredServiceWhereInput[]
    OR?: CoveredServiceWhereInput[]
    NOT?: CoveredServiceWhereInput | CoveredServiceWhereInput[]
    specific_service_id?: IntFilter<"CoveredService"> | number
    certificate_id?: IntFilter<"CoveredService"> | number
    certificate?: XOR<CertificateScalarRelationFilter, CertificateWhereInput>
    specific_service?: XOR<SpecificServiceScalarRelationFilter, SpecificServiceWhereInput>
  }, "covered_service_id">

  export type CoveredServiceOrderByWithAggregationInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
    _count?: CoveredServiceCountOrderByAggregateInput
    _avg?: CoveredServiceAvgOrderByAggregateInput
    _max?: CoveredServiceMaxOrderByAggregateInput
    _min?: CoveredServiceMinOrderByAggregateInput
    _sum?: CoveredServiceSumOrderByAggregateInput
  }

  export type CoveredServiceScalarWhereWithAggregatesInput = {
    AND?: CoveredServiceScalarWhereWithAggregatesInput | CoveredServiceScalarWhereWithAggregatesInput[]
    OR?: CoveredServiceScalarWhereWithAggregatesInput[]
    NOT?: CoveredServiceScalarWhereWithAggregatesInput | CoveredServiceScalarWhereWithAggregatesInput[]
    covered_service_id?: IntWithAggregatesFilter<"CoveredService"> | number
    specific_service_id?: IntWithAggregatesFilter<"CoveredService"> | number
    certificate_id?: IntWithAggregatesFilter<"CoveredService"> | number
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    availability_id?: IntFilter<"Availability"> | number
    dayOfWeek?: StringFilter<"Availability"> | string
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    provider_id?: IntFilter<"Availability"> | number
    availability_isActive?: BoolFilter<"Availability"> | boolean
    appointments?: AppointmentListRelationFilter
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    availability_id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    provider_id?: SortOrder
    availability_isActive?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    serviceProvider?: ServiceProviderDetailsOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    availability_id?: number
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    dayOfWeek?: StringFilter<"Availability"> | string
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    provider_id?: IntFilter<"Availability"> | number
    availability_isActive?: BoolFilter<"Availability"> | boolean
    appointments?: AppointmentListRelationFilter
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
  }, "availability_id">

  export type AvailabilityOrderByWithAggregationInput = {
    availability_id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    provider_id?: SortOrder
    availability_isActive?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _avg?: AvailabilityAvgOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
    _sum?: AvailabilitySumOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    availability_id?: IntWithAggregatesFilter<"Availability"> | number
    dayOfWeek?: StringWithAggregatesFilter<"Availability"> | string
    startTime?: StringWithAggregatesFilter<"Availability"> | string
    endTime?: StringWithAggregatesFilter<"Availability"> | string
    provider_id?: IntWithAggregatesFilter<"Availability"> | number
    availability_isActive?: BoolWithAggregatesFilter<"Availability"> | boolean
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    appointment_id?: IntFilter<"Appointment"> | number
    customer_id?: IntFilter<"Appointment"> | number
    provider_id?: IntFilter<"Appointment"> | number
    appointment_status?: StringFilter<"Appointment"> | string
    scheduled_date?: DateTimeFilter<"Appointment"> | Date | string
    repairDescription?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    final_price?: FloatNullableFilter<"Appointment"> | number | null
    availability_id?: IntFilter<"Appointment"> | number
    service_id?: IntFilter<"Appointment"> | number
    cancellation_reason?: StringNullableFilter<"Appointment"> | string | null
    availability?: XOR<AvailabilityScalarRelationFilter, AvailabilityWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    service?: XOR<ServiceListingScalarRelationFilter, ServiceListingWhereInput>
    appointment_rating?: RatingListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    appointment_status?: SortOrder
    scheduled_date?: SortOrder
    repairDescription?: SortOrderInput | SortOrder
    created_at?: SortOrder
    final_price?: SortOrderInput | SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    availability?: AvailabilityOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
    serviceProvider?: ServiceProviderDetailsOrderByWithRelationInput
    service?: ServiceListingOrderByWithRelationInput
    appointment_rating?: RatingOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    appointment_id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    customer_id?: IntFilter<"Appointment"> | number
    provider_id?: IntFilter<"Appointment"> | number
    appointment_status?: StringFilter<"Appointment"> | string
    scheduled_date?: DateTimeFilter<"Appointment"> | Date | string
    repairDescription?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    final_price?: FloatNullableFilter<"Appointment"> | number | null
    availability_id?: IntFilter<"Appointment"> | number
    service_id?: IntFilter<"Appointment"> | number
    cancellation_reason?: StringNullableFilter<"Appointment"> | string | null
    availability?: XOR<AvailabilityScalarRelationFilter, AvailabilityWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    service?: XOR<ServiceListingScalarRelationFilter, ServiceListingWhereInput>
    appointment_rating?: RatingListRelationFilter
  }, "appointment_id">

  export type AppointmentOrderByWithAggregationInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    appointment_status?: SortOrder
    scheduled_date?: SortOrder
    repairDescription?: SortOrderInput | SortOrder
    created_at?: SortOrder
    final_price?: SortOrderInput | SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    appointment_id?: IntWithAggregatesFilter<"Appointment"> | number
    customer_id?: IntWithAggregatesFilter<"Appointment"> | number
    provider_id?: IntWithAggregatesFilter<"Appointment"> | number
    appointment_status?: StringWithAggregatesFilter<"Appointment"> | string
    scheduled_date?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    repairDescription?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    final_price?: FloatNullableWithAggregatesFilter<"Appointment"> | number | null
    availability_id?: IntWithAggregatesFilter<"Appointment"> | number
    service_id?: IntWithAggregatesFilter<"Appointment"> | number
    cancellation_reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: IntFilter<"Rating"> | number
    rating_value?: IntFilter<"Rating"> | number
    rating_comment?: StringNullableFilter<"Rating"> | string | null
    appointment_id?: IntFilter<"Rating"> | number
    user_id?: IntFilter<"Rating"> | number
    provider_id?: IntFilter<"Rating"> | number
    rated_by?: StringFilter<"Rating"> | string
    created_at?: DateTimeFilter<"Rating"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    rating_value?: SortOrder
    rating_comment?: SortOrderInput | SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
    rated_by?: SortOrder
    created_at?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    serviceProvider?: ServiceProviderDetailsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    rating_value?: IntFilter<"Rating"> | number
    rating_comment?: StringNullableFilter<"Rating"> | string | null
    appointment_id?: IntFilter<"Rating"> | number
    user_id?: IntFilter<"Rating"> | number
    provider_id?: IntFilter<"Rating"> | number
    rated_by?: StringFilter<"Rating"> | string
    created_at?: DateTimeFilter<"Rating"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    serviceProvider?: XOR<ServiceProviderDetailsScalarRelationFilter, ServiceProviderDetailsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    rating_value?: SortOrder
    rating_comment?: SortOrderInput | SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
    rated_by?: SortOrder
    created_at?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rating"> | number
    rating_value?: IntWithAggregatesFilter<"Rating"> | number
    rating_comment?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    appointment_id?: IntWithAggregatesFilter<"Rating"> | number
    user_id?: IntWithAggregatesFilter<"Rating"> | number
    provider_id?: IntWithAggregatesFilter<"Rating"> | number
    rated_by?: StringWithAggregatesFilter<"Rating"> | string
    created_at?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type OTPVerificationWhereInput = {
    AND?: OTPVerificationWhereInput | OTPVerificationWhereInput[]
    OR?: OTPVerificationWhereInput[]
    NOT?: OTPVerificationWhereInput | OTPVerificationWhereInput[]
    id?: IntFilter<"OTPVerification"> | number
    email?: StringFilter<"OTPVerification"> | string
    otp?: StringFilter<"OTPVerification"> | string
    expires_at?: DateTimeFilter<"OTPVerification"> | Date | string
    created_at?: DateTimeFilter<"OTPVerification"> | Date | string
  }

  export type OTPVerificationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type OTPVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OTPVerificationWhereInput | OTPVerificationWhereInput[]
    OR?: OTPVerificationWhereInput[]
    NOT?: OTPVerificationWhereInput | OTPVerificationWhereInput[]
    email?: StringFilter<"OTPVerification"> | string
    otp?: StringFilter<"OTPVerification"> | string
    expires_at?: DateTimeFilter<"OTPVerification"> | Date | string
    created_at?: DateTimeFilter<"OTPVerification"> | Date | string
  }, "id">

  export type OTPVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    _count?: OTPVerificationCountOrderByAggregateInput
    _avg?: OTPVerificationAvgOrderByAggregateInput
    _max?: OTPVerificationMaxOrderByAggregateInput
    _min?: OTPVerificationMinOrderByAggregateInput
    _sum?: OTPVerificationSumOrderByAggregateInput
  }

  export type OTPVerificationScalarWhereWithAggregatesInput = {
    AND?: OTPVerificationScalarWhereWithAggregatesInput | OTPVerificationScalarWhereWithAggregatesInput[]
    OR?: OTPVerificationScalarWhereWithAggregatesInput[]
    NOT?: OTPVerificationScalarWhereWithAggregatesInput | OTPVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OTPVerification"> | number
    email?: StringWithAggregatesFilter<"OTPVerification"> | string
    otp?: StringWithAggregatesFilter<"OTPVerification"> | string
    expires_at?: DateTimeWithAggregatesFilter<"OTPVerification"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"OTPVerification"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    admin_id?: IntFilter<"Admin"> | number
    admin_username?: StringFilter<"Admin"> | string
    admin_email?: StringFilter<"Admin"> | string
    admin_password?: StringFilter<"Admin"> | string
    admin_name?: StringFilter<"Admin"> | string
    admin_role?: StringFilter<"Admin"> | string
    created_at?: DateTimeFilter<"Admin"> | Date | string
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    is_active?: BoolFilter<"Admin"> | boolean
  }

  export type AdminOrderByWithRelationInput = {
    admin_id?: SortOrder
    admin_username?: SortOrder
    admin_email?: SortOrder
    admin_password?: SortOrder
    admin_name?: SortOrder
    admin_role?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrderInput | SortOrder
    is_active?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    admin_id?: number
    admin_username?: string
    admin_email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    admin_password?: StringFilter<"Admin"> | string
    admin_name?: StringFilter<"Admin"> | string
    admin_role?: StringFilter<"Admin"> | string
    created_at?: DateTimeFilter<"Admin"> | Date | string
    last_login?: DateTimeNullableFilter<"Admin"> | Date | string | null
    is_active?: BoolFilter<"Admin"> | boolean
  }, "admin_id" | "admin_username" | "admin_email">

  export type AdminOrderByWithAggregationInput = {
    admin_id?: SortOrder
    admin_username?: SortOrder
    admin_email?: SortOrder
    admin_password?: SortOrder
    admin_name?: SortOrder
    admin_role?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrderInput | SortOrder
    is_active?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    admin_id?: IntWithAggregatesFilter<"Admin"> | number
    admin_username?: StringWithAggregatesFilter<"Admin"> | string
    admin_email?: StringWithAggregatesFilter<"Admin"> | string
    admin_password?: StringWithAggregatesFilter<"Admin"> | string
    admin_name?: StringWithAggregatesFilter<"Admin"> | string
    admin_role?: StringWithAggregatesFilter<"Admin"> | string
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    last_login?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"Admin"> | boolean
  }

  export type UserCreateInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    user_rating?: RatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    user_rating?: RatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    user_rating?: RatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    user_rating?: RatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
  }

  export type UserUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProviderDetailsCreateInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateUncheckedCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUpdateInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUncheckedUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsCreateManyInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
  }

  export type ServiceProviderDetailsUpdateManyMutationInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProviderDetailsUncheckedUpdateManyInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateCreateInput = {
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
    provider: ServiceProviderDetailsCreateNestedOneWithoutProvider_certificatesInput
    CoveredService?: CoveredServiceCreateNestedManyWithoutCertificateInput
  }

  export type CertificateUncheckedCreateInput = {
    certificate_id?: number
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    provider_id: number
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
    CoveredService?: CoveredServiceUncheckedCreateNestedManyWithoutCertificateInput
  }

  export type CertificateUpdateInput = {
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_certificatesNestedInput
    CoveredService?: CoveredServiceUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_id?: IntFieldUpdateOperationsInput | number
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    CoveredService?: CoveredServiceUncheckedUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateCreateManyInput = {
    certificate_id?: number
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    provider_id: number
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_id?: IntFieldUpdateOperationsInput | number
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListingCreateInput = {
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_servicesInput
    specific_services?: SpecificServiceCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingUncheckedCreateInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    provider_id: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
    specific_services?: SpecificServiceUncheckedCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingUpdateInput = {
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_servicesNestedInput
    specific_services?: SpecificServiceUpdateManyWithoutServiceListingNestedInput
  }

  export type ServiceListingUncheckedUpdateInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
    specific_services?: SpecificServiceUncheckedUpdateManyWithoutServiceListingNestedInput
  }

  export type ServiceListingCreateManyInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    provider_id: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
  }

  export type ServiceListingUpdateManyMutationInput = {
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceListingUncheckedUpdateManyInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCategoryCreateInput = {
    category_name: string
    specific_services?: SpecificServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    category_id?: number
    category_name: string
    specific_services?: SpecificServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    specific_services?: SpecificServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    specific_services?: SpecificServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    category_id?: number
    category_name: string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificServiceCreateInput = {
    specific_service_title: string
    specific_service_description: string
    covered_by_certificates?: CoveredServiceCreateNestedManyWithoutSpecific_serviceInput
    category: ServiceCategoryCreateNestedOneWithoutSpecific_servicesInput
    serviceListing: ServiceListingCreateNestedOneWithoutSpecific_servicesInput
  }

  export type SpecificServiceUncheckedCreateInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
    category_id: number
    covered_by_certificates?: CoveredServiceUncheckedCreateNestedManyWithoutSpecific_serviceInput
  }

  export type SpecificServiceUpdateInput = {
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    covered_by_certificates?: CoveredServiceUpdateManyWithoutSpecific_serviceNestedInput
    category?: ServiceCategoryUpdateOneRequiredWithoutSpecific_servicesNestedInput
    serviceListing?: ServiceListingUpdateOneRequiredWithoutSpecific_servicesNestedInput
  }

  export type SpecificServiceUncheckedUpdateInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    covered_by_certificates?: CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceNestedInput
  }

  export type SpecificServiceCreateManyInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
    category_id: number
  }

  export type SpecificServiceUpdateManyMutationInput = {
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificServiceUncheckedUpdateManyInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoveredServiceCreateInput = {
    certificate: CertificateCreateNestedOneWithoutCoveredServiceInput
    specific_service: SpecificServiceCreateNestedOneWithoutCovered_by_certificatesInput
  }

  export type CoveredServiceUncheckedCreateInput = {
    covered_service_id?: number
    specific_service_id: number
    certificate_id: number
  }

  export type CoveredServiceUpdateInput = {
    certificate?: CertificateUpdateOneRequiredWithoutCoveredServiceNestedInput
    specific_service?: SpecificServiceUpdateOneRequiredWithoutCovered_by_certificatesNestedInput
  }

  export type CoveredServiceUncheckedUpdateInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoveredServiceCreateManyInput = {
    covered_service_id?: number
    specific_service_id: number
    certificate_id: number
  }

  export type CoveredServiceUpdateManyMutationInput = {

  }

  export type CoveredServiceUncheckedUpdateManyInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
  }

  export type AvailabilityCreateInput = {
    dayOfWeek: string
    startTime: string
    endTime: string
    availability_isActive?: boolean
    appointments?: AppointmentCreateNestedManyWithoutAvailabilityInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_availabilityInput
  }

  export type AvailabilityUncheckedCreateInput = {
    availability_id?: number
    dayOfWeek: string
    startTime: string
    endTime: string
    provider_id: number
    availability_isActive?: boolean
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAvailabilityInput
  }

  export type AvailabilityUpdateInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
    appointments?: AppointmentUpdateManyWithoutAvailabilityNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_availabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    provider_id?: IntFieldUpdateOperationsInput | number
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
    appointments?: AppointmentUncheckedUpdateManyWithoutAvailabilityNestedInput
  }

  export type AvailabilityCreateManyInput = {
    availability_id?: number
    dayOfWeek: string
    startTime: string
    endTime: string
    provider_id: number
    availability_isActive?: boolean
  }

  export type AvailabilityUpdateManyMutationInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    provider_id?: IntFieldUpdateOperationsInput | number
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentCreateInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    availability: AvailabilityCreateNestedOneWithoutAppointmentsInput
    customer: UserCreateNestedOneWithoutUser_appointmentsInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput
    service: ServiceListingCreateNestedOneWithoutAppointmentsInput
    appointment_rating?: RatingCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
    appointment_rating?: RatingUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput
    customer?: UserUpdateOneRequiredWithoutUser_appointmentsNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput
    service?: ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput
    appointment_rating?: RatingUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_rating?: RatingUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingCreateInput = {
    rating_value: number
    rating_comment?: string | null
    rated_by: string
    created_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutAppointment_ratingInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_ratingsInput
    user: UserCreateNestedOneWithoutUser_ratingInput
  }

  export type RatingUncheckedCreateInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    user_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingUpdateInput = {
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutAppointment_ratingNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_ratingsNestedInput
    user?: UserUpdateOneRequiredWithoutUser_ratingNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    user_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPVerificationCreateInput = {
    email: string
    otp: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type OTPVerificationUncheckedCreateInput = {
    id?: number
    email: string
    otp: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type OTPVerificationUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPVerificationCreateManyInput = {
    id?: number
    email: string
    otp: string
    expires_at: Date | string
    created_at?: Date | string
  }

  export type OTPVerificationUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    admin_username: string
    admin_email: string
    admin_password: string
    admin_name: string
    admin_role?: string
    created_at?: Date | string
    last_login?: Date | string | null
    is_active?: boolean
  }

  export type AdminUncheckedCreateInput = {
    admin_id?: number
    admin_username: string
    admin_email: string
    admin_password: string
    admin_name: string
    admin_role?: string
    created_at?: Date | string
    last_login?: Date | string | null
    is_active?: boolean
  }

  export type AdminUpdateInput = {
    admin_username?: StringFieldUpdateOperationsInput | string
    admin_email?: StringFieldUpdateOperationsInput | string
    admin_password?: StringFieldUpdateOperationsInput | string
    admin_name?: StringFieldUpdateOperationsInput | string
    admin_role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUncheckedUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    admin_username?: StringFieldUpdateOperationsInput | string
    admin_email?: StringFieldUpdateOperationsInput | string
    admin_password?: StringFieldUpdateOperationsInput | string
    admin_name?: StringFieldUpdateOperationsInput | string
    admin_role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateManyInput = {
    admin_id?: number
    admin_username: string
    admin_email: string
    admin_password: string
    admin_name: string
    admin_role?: string
    created_at?: Date | string
    last_login?: Date | string | null
    is_active?: boolean
  }

  export type AdminUpdateManyMutationInput = {
    admin_username?: StringFieldUpdateOperationsInput | string
    admin_email?: StringFieldUpdateOperationsInput | string
    admin_password?: StringFieldUpdateOperationsInput | string
    admin_name?: StringFieldUpdateOperationsInput | string
    admin_role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUncheckedUpdateManyInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    admin_username?: StringFieldUpdateOperationsInput | string
    admin_email?: StringFieldUpdateOperationsInput | string
    admin_password?: StringFieldUpdateOperationsInput | string
    admin_name?: StringFieldUpdateOperationsInput | string
    admin_role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    profile_photo?: SortOrder
    valid_id?: SortOrder
    user_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    password?: SortOrder
    userName?: SortOrder
    is_activated?: SortOrder
    birthday?: SortOrder
    exact_location?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    profile_photo?: SortOrder
    valid_id?: SortOrder
    user_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    password?: SortOrder
    userName?: SortOrder
    is_activated?: SortOrder
    birthday?: SortOrder
    exact_location?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    profile_photo?: SortOrder
    valid_id?: SortOrder
    user_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    password?: SortOrder
    userName?: SortOrder
    is_activated?: SortOrder
    birthday?: SortOrder
    exact_location?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type ServiceListingListRelationFilter = {
    every?: ServiceListingWhereInput
    some?: ServiceListingWhereInput
    none?: ServiceListingWhereInput
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceProviderDetailsCountOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_first_name?: SortOrder
    provider_last_name?: SortOrder
    provider_email?: SortOrder
    provider_phone_number?: SortOrder
    provider_profile_photo?: SortOrder
    provider_valid_id?: SortOrder
    provider_isVerified?: SortOrder
    created_at?: SortOrder
    provider_rating?: SortOrder
    provider_location?: SortOrder
    provider_uli?: SortOrder
    provider_password?: SortOrder
    provider_userName?: SortOrder
    provider_isActivated?: SortOrder
    provider_birthday?: SortOrder
    provider_exact_location?: SortOrder
  }

  export type ServiceProviderDetailsAvgOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_rating?: SortOrder
  }

  export type ServiceProviderDetailsMaxOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_first_name?: SortOrder
    provider_last_name?: SortOrder
    provider_email?: SortOrder
    provider_phone_number?: SortOrder
    provider_profile_photo?: SortOrder
    provider_valid_id?: SortOrder
    provider_isVerified?: SortOrder
    created_at?: SortOrder
    provider_rating?: SortOrder
    provider_location?: SortOrder
    provider_uli?: SortOrder
    provider_password?: SortOrder
    provider_userName?: SortOrder
    provider_isActivated?: SortOrder
    provider_birthday?: SortOrder
    provider_exact_location?: SortOrder
  }

  export type ServiceProviderDetailsMinOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_first_name?: SortOrder
    provider_last_name?: SortOrder
    provider_email?: SortOrder
    provider_phone_number?: SortOrder
    provider_profile_photo?: SortOrder
    provider_valid_id?: SortOrder
    provider_isVerified?: SortOrder
    created_at?: SortOrder
    provider_rating?: SortOrder
    provider_location?: SortOrder
    provider_uli?: SortOrder
    provider_password?: SortOrder
    provider_userName?: SortOrder
    provider_isActivated?: SortOrder
    provider_birthday?: SortOrder
    provider_exact_location?: SortOrder
  }

  export type ServiceProviderDetailsSumOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceProviderDetailsScalarRelationFilter = {
    is?: ServiceProviderDetailsWhereInput
    isNot?: ServiceProviderDetailsWhereInput
  }

  export type CoveredServiceListRelationFilter = {
    every?: CoveredServiceWhereInput
    some?: CoveredServiceWhereInput
    none?: CoveredServiceWhereInput
  }

  export type CoveredServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    certificate_id?: SortOrder
    certificate_name?: SortOrder
    certificate_file_path?: SortOrder
    expiry_date?: SortOrder
    provider_id?: SortOrder
    certificate_number?: SortOrder
    certificate_status?: SortOrder
    created_at?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    certificate_id?: SortOrder
    provider_id?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    certificate_id?: SortOrder
    certificate_name?: SortOrder
    certificate_file_path?: SortOrder
    expiry_date?: SortOrder
    provider_id?: SortOrder
    certificate_number?: SortOrder
    certificate_status?: SortOrder
    created_at?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    certificate_id?: SortOrder
    certificate_name?: SortOrder
    certificate_file_path?: SortOrder
    expiry_date?: SortOrder
    provider_id?: SortOrder
    certificate_number?: SortOrder
    certificate_status?: SortOrder
    created_at?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    certificate_id?: SortOrder
    provider_id?: SortOrder
  }

  export type SpecificServiceListRelationFilter = {
    every?: SpecificServiceWhereInput
    some?: SpecificServiceWhereInput
    none?: SpecificServiceWhereInput
  }

  export type SpecificServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceListingCountOrderByAggregateInput = {
    service_id?: SortOrder
    service_title?: SortOrder
    service_description?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
    servicelisting_isActive?: SortOrder
    service_picture?: SortOrder
  }

  export type ServiceListingAvgOrderByAggregateInput = {
    service_id?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
  }

  export type ServiceListingMaxOrderByAggregateInput = {
    service_id?: SortOrder
    service_title?: SortOrder
    service_description?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
    servicelisting_isActive?: SortOrder
    service_picture?: SortOrder
  }

  export type ServiceListingMinOrderByAggregateInput = {
    service_id?: SortOrder
    service_title?: SortOrder
    service_description?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
    servicelisting_isActive?: SortOrder
    service_picture?: SortOrder
  }

  export type ServiceListingSumOrderByAggregateInput = {
    service_id?: SortOrder
    service_startingprice?: SortOrder
    provider_id?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type ServiceCategoryAvgOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type ServiceCategorySumOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type ServiceListingScalarRelationFilter = {
    is?: ServiceListingWhereInput
    isNot?: ServiceListingWhereInput
  }

  export type SpecificServiceCountOrderByAggregateInput = {
    specific_service_id?: SortOrder
    specific_service_title?: SortOrder
    specific_service_description?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
  }

  export type SpecificServiceAvgOrderByAggregateInput = {
    specific_service_id?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
  }

  export type SpecificServiceMaxOrderByAggregateInput = {
    specific_service_id?: SortOrder
    specific_service_title?: SortOrder
    specific_service_description?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
  }

  export type SpecificServiceMinOrderByAggregateInput = {
    specific_service_id?: SortOrder
    specific_service_title?: SortOrder
    specific_service_description?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
  }

  export type SpecificServiceSumOrderByAggregateInput = {
    specific_service_id?: SortOrder
    service_id?: SortOrder
    category_id?: SortOrder
  }

  export type CertificateScalarRelationFilter = {
    is?: CertificateWhereInput
    isNot?: CertificateWhereInput
  }

  export type SpecificServiceScalarRelationFilter = {
    is?: SpecificServiceWhereInput
    isNot?: SpecificServiceWhereInput
  }

  export type CoveredServiceCountOrderByAggregateInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
  }

  export type CoveredServiceAvgOrderByAggregateInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
  }

  export type CoveredServiceMaxOrderByAggregateInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
  }

  export type CoveredServiceMinOrderByAggregateInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
  }

  export type CoveredServiceSumOrderByAggregateInput = {
    covered_service_id?: SortOrder
    specific_service_id?: SortOrder
    certificate_id?: SortOrder
  }

  export type AvailabilityCountOrderByAggregateInput = {
    availability_id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    provider_id?: SortOrder
    availability_isActive?: SortOrder
  }

  export type AvailabilityAvgOrderByAggregateInput = {
    availability_id?: SortOrder
    provider_id?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    availability_id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    provider_id?: SortOrder
    availability_isActive?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    availability_id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    provider_id?: SortOrder
    availability_isActive?: SortOrder
  }

  export type AvailabilitySumOrderByAggregateInput = {
    availability_id?: SortOrder
    provider_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AvailabilityScalarRelationFilter = {
    is?: AvailabilityWhereInput
    isNot?: AvailabilityWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    appointment_status?: SortOrder
    scheduled_date?: SortOrder
    repairDescription?: SortOrder
    created_at?: SortOrder
    final_price?: SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    final_price?: SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    appointment_status?: SortOrder
    scheduled_date?: SortOrder
    repairDescription?: SortOrder
    created_at?: SortOrder
    final_price?: SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    appointment_status?: SortOrder
    scheduled_date?: SortOrder
    repairDescription?: SortOrder
    created_at?: SortOrder
    final_price?: SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    appointment_id?: SortOrder
    customer_id?: SortOrder
    provider_id?: SortOrder
    final_price?: SortOrder
    availability_id?: SortOrder
    service_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    rating_value?: SortOrder
    rating_comment?: SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
    rated_by?: SortOrder
    created_at?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    id?: SortOrder
    rating_value?: SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    rating_value?: SortOrder
    rating_comment?: SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
    rated_by?: SortOrder
    created_at?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    rating_value?: SortOrder
    rating_comment?: SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
    rated_by?: SortOrder
    created_at?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    id?: SortOrder
    rating_value?: SortOrder
    appointment_id?: SortOrder
    user_id?: SortOrder
    provider_id?: SortOrder
  }

  export type OTPVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type OTPVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OTPVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type OTPVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type OTPVerificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    admin_id?: SortOrder
    admin_username?: SortOrder
    admin_email?: SortOrder
    admin_password?: SortOrder
    admin_name?: SortOrder
    admin_role?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    is_active?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    admin_id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    admin_id?: SortOrder
    admin_username?: SortOrder
    admin_email?: SortOrder
    admin_password?: SortOrder
    admin_name?: SortOrder
    admin_role?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    is_active?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    admin_id?: SortOrder
    admin_username?: SortOrder
    admin_email?: SortOrder
    admin_password?: SortOrder
    admin_name?: SortOrder
    admin_role?: SortOrder
    created_at?: SortOrder
    last_login?: SortOrder
    is_active?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    admin_id?: SortOrder
  }

  export type AppointmentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AppointmentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCustomerInput | AppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCustomerInput | AppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCustomerInput | AppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCustomerInput | AppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCustomerInput | AppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCustomerInput | AppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AvailabilityCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput> | AvailabilityCreateWithoutServiceProviderInput[] | AvailabilityUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutServiceProviderInput | AvailabilityCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AvailabilityCreateManyServiceProviderInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutProviderInput = {
    create?: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput> | CertificateCreateWithoutProviderInput[] | CertificateUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutProviderInput | CertificateCreateOrConnectWithoutProviderInput[]
    createMany?: CertificateCreateManyProviderInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type ServiceListingCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput> | ServiceListingCreateWithoutServiceProviderInput[] | ServiceListingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: ServiceListingCreateOrConnectWithoutServiceProviderInput | ServiceListingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: ServiceListingCreateManyServiceProviderInputEnvelope
    connect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput> | AvailabilityCreateWithoutServiceProviderInput[] | AvailabilityUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutServiceProviderInput | AvailabilityCreateOrConnectWithoutServiceProviderInput[]
    createMany?: AvailabilityCreateManyServiceProviderInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput> | CertificateCreateWithoutProviderInput[] | CertificateUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutProviderInput | CertificateCreateOrConnectWithoutProviderInput[]
    createMany?: CertificateCreateManyProviderInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput> | ServiceListingCreateWithoutServiceProviderInput[] | ServiceListingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: ServiceListingCreateOrConnectWithoutServiceProviderInput | ServiceListingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: ServiceListingCreateManyServiceProviderInputEnvelope
    connect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AvailabilityUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput> | AvailabilityCreateWithoutServiceProviderInput[] | AvailabilityUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutServiceProviderInput | AvailabilityCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput | AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AvailabilityCreateManyServiceProviderInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput | AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutServiceProviderInput | AvailabilityUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput> | CertificateCreateWithoutProviderInput[] | CertificateUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutProviderInput | CertificateCreateOrConnectWithoutProviderInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutProviderInput | CertificateUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CertificateCreateManyProviderInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutProviderInput | CertificateUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutProviderInput | CertificateUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutServiceProviderInput | RatingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutServiceProviderInput | RatingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutServiceProviderInput | RatingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type ServiceListingUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput> | ServiceListingCreateWithoutServiceProviderInput[] | ServiceListingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: ServiceListingCreateOrConnectWithoutServiceProviderInput | ServiceListingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: ServiceListingUpsertWithWhereUniqueWithoutServiceProviderInput | ServiceListingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: ServiceListingCreateManyServiceProviderInputEnvelope
    set?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    disconnect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    delete?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    connect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    update?: ServiceListingUpdateWithWhereUniqueWithoutServiceProviderInput | ServiceListingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: ServiceListingUpdateManyWithWhereWithoutServiceProviderInput | ServiceListingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: ServiceListingScalarWhereInput | ServiceListingScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput> | AppointmentCreateWithoutServiceProviderInput[] | AppointmentUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceProviderInput | AppointmentCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput | AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AppointmentCreateManyServiceProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput | AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceProviderInput | AppointmentUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput> | AvailabilityCreateWithoutServiceProviderInput[] | AvailabilityUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutServiceProviderInput | AvailabilityCreateOrConnectWithoutServiceProviderInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput | AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: AvailabilityCreateManyServiceProviderInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput | AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutServiceProviderInput | AvailabilityUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput> | CertificateCreateWithoutProviderInput[] | CertificateUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutProviderInput | CertificateCreateOrConnectWithoutProviderInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutProviderInput | CertificateUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CertificateCreateManyProviderInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutProviderInput | CertificateUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutProviderInput | CertificateUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput> | RatingCreateWithoutServiceProviderInput[] | RatingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutServiceProviderInput | RatingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutServiceProviderInput | RatingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: RatingCreateManyServiceProviderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutServiceProviderInput | RatingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutServiceProviderInput | RatingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput> | ServiceListingCreateWithoutServiceProviderInput[] | ServiceListingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: ServiceListingCreateOrConnectWithoutServiceProviderInput | ServiceListingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: ServiceListingUpsertWithWhereUniqueWithoutServiceProviderInput | ServiceListingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: ServiceListingCreateManyServiceProviderInputEnvelope
    set?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    disconnect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    delete?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    connect?: ServiceListingWhereUniqueInput | ServiceListingWhereUniqueInput[]
    update?: ServiceListingUpdateWithWhereUniqueWithoutServiceProviderInput | ServiceListingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: ServiceListingUpdateManyWithWhereWithoutServiceProviderInput | ServiceListingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: ServiceListingScalarWhereInput | ServiceListingScalarWhereInput[]
  }

  export type ServiceProviderDetailsCreateNestedOneWithoutProvider_certificatesInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_certificatesInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_certificatesInput
    connect?: ServiceProviderDetailsWhereUniqueInput
  }

  export type CoveredServiceCreateNestedManyWithoutCertificateInput = {
    create?: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput> | CoveredServiceCreateWithoutCertificateInput[] | CoveredServiceUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutCertificateInput | CoveredServiceCreateOrConnectWithoutCertificateInput[]
    createMany?: CoveredServiceCreateManyCertificateInputEnvelope
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
  }

  export type CoveredServiceUncheckedCreateNestedManyWithoutCertificateInput = {
    create?: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput> | CoveredServiceCreateWithoutCertificateInput[] | CoveredServiceUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutCertificateInput | CoveredServiceCreateOrConnectWithoutCertificateInput[]
    createMany?: CoveredServiceCreateManyCertificateInputEnvelope
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
  }

  export type ServiceProviderDetailsUpdateOneRequiredWithoutProvider_certificatesNestedInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_certificatesInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_certificatesInput
    upsert?: ServiceProviderDetailsUpsertWithoutProvider_certificatesInput
    connect?: ServiceProviderDetailsWhereUniqueInput
    update?: XOR<XOR<ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_certificatesInput, ServiceProviderDetailsUpdateWithoutProvider_certificatesInput>, ServiceProviderDetailsUncheckedUpdateWithoutProvider_certificatesInput>
  }

  export type CoveredServiceUpdateManyWithoutCertificateNestedInput = {
    create?: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput> | CoveredServiceCreateWithoutCertificateInput[] | CoveredServiceUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutCertificateInput | CoveredServiceCreateOrConnectWithoutCertificateInput[]
    upsert?: CoveredServiceUpsertWithWhereUniqueWithoutCertificateInput | CoveredServiceUpsertWithWhereUniqueWithoutCertificateInput[]
    createMany?: CoveredServiceCreateManyCertificateInputEnvelope
    set?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    disconnect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    delete?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    update?: CoveredServiceUpdateWithWhereUniqueWithoutCertificateInput | CoveredServiceUpdateWithWhereUniqueWithoutCertificateInput[]
    updateMany?: CoveredServiceUpdateManyWithWhereWithoutCertificateInput | CoveredServiceUpdateManyWithWhereWithoutCertificateInput[]
    deleteMany?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
  }

  export type CoveredServiceUncheckedUpdateManyWithoutCertificateNestedInput = {
    create?: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput> | CoveredServiceCreateWithoutCertificateInput[] | CoveredServiceUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutCertificateInput | CoveredServiceCreateOrConnectWithoutCertificateInput[]
    upsert?: CoveredServiceUpsertWithWhereUniqueWithoutCertificateInput | CoveredServiceUpsertWithWhereUniqueWithoutCertificateInput[]
    createMany?: CoveredServiceCreateManyCertificateInputEnvelope
    set?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    disconnect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    delete?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    update?: CoveredServiceUpdateWithWhereUniqueWithoutCertificateInput | CoveredServiceUpdateWithWhereUniqueWithoutCertificateInput[]
    updateMany?: CoveredServiceUpdateManyWithWhereWithoutCertificateInput | CoveredServiceUpdateManyWithWhereWithoutCertificateInput[]
    deleteMany?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ServiceProviderDetailsCreateNestedOneWithoutProvider_servicesInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_servicesInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_servicesInput
    connect?: ServiceProviderDetailsWhereUniqueInput
  }

  export type SpecificServiceCreateNestedManyWithoutServiceListingInput = {
    create?: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput> | SpecificServiceCreateWithoutServiceListingInput[] | SpecificServiceUncheckedCreateWithoutServiceListingInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutServiceListingInput | SpecificServiceCreateOrConnectWithoutServiceListingInput[]
    createMany?: SpecificServiceCreateManyServiceListingInputEnvelope
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SpecificServiceUncheckedCreateNestedManyWithoutServiceListingInput = {
    create?: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput> | SpecificServiceCreateWithoutServiceListingInput[] | SpecificServiceUncheckedCreateWithoutServiceListingInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutServiceListingInput | SpecificServiceCreateOrConnectWithoutServiceListingInput[]
    createMany?: SpecificServiceCreateManyServiceListingInputEnvelope
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ServiceProviderDetailsUpdateOneRequiredWithoutProvider_servicesNestedInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_servicesInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_servicesInput
    upsert?: ServiceProviderDetailsUpsertWithoutProvider_servicesInput
    connect?: ServiceProviderDetailsWhereUniqueInput
    update?: XOR<XOR<ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_servicesInput, ServiceProviderDetailsUpdateWithoutProvider_servicesInput>, ServiceProviderDetailsUncheckedUpdateWithoutProvider_servicesInput>
  }

  export type SpecificServiceUpdateManyWithoutServiceListingNestedInput = {
    create?: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput> | SpecificServiceCreateWithoutServiceListingInput[] | SpecificServiceUncheckedCreateWithoutServiceListingInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutServiceListingInput | SpecificServiceCreateOrConnectWithoutServiceListingInput[]
    upsert?: SpecificServiceUpsertWithWhereUniqueWithoutServiceListingInput | SpecificServiceUpsertWithWhereUniqueWithoutServiceListingInput[]
    createMany?: SpecificServiceCreateManyServiceListingInputEnvelope
    set?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    disconnect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    delete?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    update?: SpecificServiceUpdateWithWhereUniqueWithoutServiceListingInput | SpecificServiceUpdateWithWhereUniqueWithoutServiceListingInput[]
    updateMany?: SpecificServiceUpdateManyWithWhereWithoutServiceListingInput | SpecificServiceUpdateManyWithWhereWithoutServiceListingInput[]
    deleteMany?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SpecificServiceUncheckedUpdateManyWithoutServiceListingNestedInput = {
    create?: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput> | SpecificServiceCreateWithoutServiceListingInput[] | SpecificServiceUncheckedCreateWithoutServiceListingInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutServiceListingInput | SpecificServiceCreateOrConnectWithoutServiceListingInput[]
    upsert?: SpecificServiceUpsertWithWhereUniqueWithoutServiceListingInput | SpecificServiceUpsertWithWhereUniqueWithoutServiceListingInput[]
    createMany?: SpecificServiceCreateManyServiceListingInputEnvelope
    set?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    disconnect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    delete?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    update?: SpecificServiceUpdateWithWhereUniqueWithoutServiceListingInput | SpecificServiceUpdateWithWhereUniqueWithoutServiceListingInput[]
    updateMany?: SpecificServiceUpdateManyWithWhereWithoutServiceListingInput | SpecificServiceUpdateManyWithWhereWithoutServiceListingInput[]
    deleteMany?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
  }

  export type SpecificServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput> | SpecificServiceCreateWithoutCategoryInput[] | SpecificServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCategoryInput | SpecificServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: SpecificServiceCreateManyCategoryInputEnvelope
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
  }

  export type SpecificServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput> | SpecificServiceCreateWithoutCategoryInput[] | SpecificServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCategoryInput | SpecificServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: SpecificServiceCreateManyCategoryInputEnvelope
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
  }

  export type SpecificServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput> | SpecificServiceCreateWithoutCategoryInput[] | SpecificServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCategoryInput | SpecificServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: SpecificServiceUpsertWithWhereUniqueWithoutCategoryInput | SpecificServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SpecificServiceCreateManyCategoryInputEnvelope
    set?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    disconnect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    delete?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    update?: SpecificServiceUpdateWithWhereUniqueWithoutCategoryInput | SpecificServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SpecificServiceUpdateManyWithWhereWithoutCategoryInput | SpecificServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
  }

  export type SpecificServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput> | SpecificServiceCreateWithoutCategoryInput[] | SpecificServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCategoryInput | SpecificServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: SpecificServiceUpsertWithWhereUniqueWithoutCategoryInput | SpecificServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SpecificServiceCreateManyCategoryInputEnvelope
    set?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    disconnect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    delete?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    connect?: SpecificServiceWhereUniqueInput | SpecificServiceWhereUniqueInput[]
    update?: SpecificServiceUpdateWithWhereUniqueWithoutCategoryInput | SpecificServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SpecificServiceUpdateManyWithWhereWithoutCategoryInput | SpecificServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
  }

  export type CoveredServiceCreateNestedManyWithoutSpecific_serviceInput = {
    create?: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput> | CoveredServiceCreateWithoutSpecific_serviceInput[] | CoveredServiceUncheckedCreateWithoutSpecific_serviceInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutSpecific_serviceInput | CoveredServiceCreateOrConnectWithoutSpecific_serviceInput[]
    createMany?: CoveredServiceCreateManySpecific_serviceInputEnvelope
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutSpecific_servicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutSpecific_servicesInput, ServiceCategoryUncheckedCreateWithoutSpecific_servicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutSpecific_servicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ServiceListingCreateNestedOneWithoutSpecific_servicesInput = {
    create?: XOR<ServiceListingCreateWithoutSpecific_servicesInput, ServiceListingUncheckedCreateWithoutSpecific_servicesInput>
    connectOrCreate?: ServiceListingCreateOrConnectWithoutSpecific_servicesInput
    connect?: ServiceListingWhereUniqueInput
  }

  export type CoveredServiceUncheckedCreateNestedManyWithoutSpecific_serviceInput = {
    create?: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput> | CoveredServiceCreateWithoutSpecific_serviceInput[] | CoveredServiceUncheckedCreateWithoutSpecific_serviceInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutSpecific_serviceInput | CoveredServiceCreateOrConnectWithoutSpecific_serviceInput[]
    createMany?: CoveredServiceCreateManySpecific_serviceInputEnvelope
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
  }

  export type CoveredServiceUpdateManyWithoutSpecific_serviceNestedInput = {
    create?: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput> | CoveredServiceCreateWithoutSpecific_serviceInput[] | CoveredServiceUncheckedCreateWithoutSpecific_serviceInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutSpecific_serviceInput | CoveredServiceCreateOrConnectWithoutSpecific_serviceInput[]
    upsert?: CoveredServiceUpsertWithWhereUniqueWithoutSpecific_serviceInput | CoveredServiceUpsertWithWhereUniqueWithoutSpecific_serviceInput[]
    createMany?: CoveredServiceCreateManySpecific_serviceInputEnvelope
    set?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    disconnect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    delete?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    update?: CoveredServiceUpdateWithWhereUniqueWithoutSpecific_serviceInput | CoveredServiceUpdateWithWhereUniqueWithoutSpecific_serviceInput[]
    updateMany?: CoveredServiceUpdateManyWithWhereWithoutSpecific_serviceInput | CoveredServiceUpdateManyWithWhereWithoutSpecific_serviceInput[]
    deleteMany?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
  }

  export type ServiceCategoryUpdateOneRequiredWithoutSpecific_servicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutSpecific_servicesInput, ServiceCategoryUncheckedCreateWithoutSpecific_servicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutSpecific_servicesInput
    upsert?: ServiceCategoryUpsertWithoutSpecific_servicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutSpecific_servicesInput, ServiceCategoryUpdateWithoutSpecific_servicesInput>, ServiceCategoryUncheckedUpdateWithoutSpecific_servicesInput>
  }

  export type ServiceListingUpdateOneRequiredWithoutSpecific_servicesNestedInput = {
    create?: XOR<ServiceListingCreateWithoutSpecific_servicesInput, ServiceListingUncheckedCreateWithoutSpecific_servicesInput>
    connectOrCreate?: ServiceListingCreateOrConnectWithoutSpecific_servicesInput
    upsert?: ServiceListingUpsertWithoutSpecific_servicesInput
    connect?: ServiceListingWhereUniqueInput
    update?: XOR<XOR<ServiceListingUpdateToOneWithWhereWithoutSpecific_servicesInput, ServiceListingUpdateWithoutSpecific_servicesInput>, ServiceListingUncheckedUpdateWithoutSpecific_servicesInput>
  }

  export type CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceNestedInput = {
    create?: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput> | CoveredServiceCreateWithoutSpecific_serviceInput[] | CoveredServiceUncheckedCreateWithoutSpecific_serviceInput[]
    connectOrCreate?: CoveredServiceCreateOrConnectWithoutSpecific_serviceInput | CoveredServiceCreateOrConnectWithoutSpecific_serviceInput[]
    upsert?: CoveredServiceUpsertWithWhereUniqueWithoutSpecific_serviceInput | CoveredServiceUpsertWithWhereUniqueWithoutSpecific_serviceInput[]
    createMany?: CoveredServiceCreateManySpecific_serviceInputEnvelope
    set?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    disconnect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    delete?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    connect?: CoveredServiceWhereUniqueInput | CoveredServiceWhereUniqueInput[]
    update?: CoveredServiceUpdateWithWhereUniqueWithoutSpecific_serviceInput | CoveredServiceUpdateWithWhereUniqueWithoutSpecific_serviceInput[]
    updateMany?: CoveredServiceUpdateManyWithWhereWithoutSpecific_serviceInput | CoveredServiceUpdateManyWithWhereWithoutSpecific_serviceInput[]
    deleteMany?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
  }

  export type CertificateCreateNestedOneWithoutCoveredServiceInput = {
    create?: XOR<CertificateCreateWithoutCoveredServiceInput, CertificateUncheckedCreateWithoutCoveredServiceInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutCoveredServiceInput
    connect?: CertificateWhereUniqueInput
  }

  export type SpecificServiceCreateNestedOneWithoutCovered_by_certificatesInput = {
    create?: XOR<SpecificServiceCreateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedCreateWithoutCovered_by_certificatesInput>
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCovered_by_certificatesInput
    connect?: SpecificServiceWhereUniqueInput
  }

  export type CertificateUpdateOneRequiredWithoutCoveredServiceNestedInput = {
    create?: XOR<CertificateCreateWithoutCoveredServiceInput, CertificateUncheckedCreateWithoutCoveredServiceInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutCoveredServiceInput
    upsert?: CertificateUpsertWithoutCoveredServiceInput
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutCoveredServiceInput, CertificateUpdateWithoutCoveredServiceInput>, CertificateUncheckedUpdateWithoutCoveredServiceInput>
  }

  export type SpecificServiceUpdateOneRequiredWithoutCovered_by_certificatesNestedInput = {
    create?: XOR<SpecificServiceCreateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedCreateWithoutCovered_by_certificatesInput>
    connectOrCreate?: SpecificServiceCreateOrConnectWithoutCovered_by_certificatesInput
    upsert?: SpecificServiceUpsertWithoutCovered_by_certificatesInput
    connect?: SpecificServiceWhereUniqueInput
    update?: XOR<XOR<SpecificServiceUpdateToOneWithWhereWithoutCovered_by_certificatesInput, SpecificServiceUpdateWithoutCovered_by_certificatesInput>, SpecificServiceUncheckedUpdateWithoutCovered_by_certificatesInput>
  }

  export type AppointmentCreateNestedManyWithoutAvailabilityInput = {
    create?: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput> | AppointmentCreateWithoutAvailabilityInput[] | AppointmentUncheckedCreateWithoutAvailabilityInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAvailabilityInput | AppointmentCreateOrConnectWithoutAvailabilityInput[]
    createMany?: AppointmentCreateManyAvailabilityInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ServiceProviderDetailsCreateNestedOneWithoutProvider_availabilityInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_availabilityInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_availabilityInput
    connect?: ServiceProviderDetailsWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutAvailabilityInput = {
    create?: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput> | AppointmentCreateWithoutAvailabilityInput[] | AppointmentUncheckedCreateWithoutAvailabilityInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAvailabilityInput | AppointmentCreateOrConnectWithoutAvailabilityInput[]
    createMany?: AppointmentCreateManyAvailabilityInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutAvailabilityNestedInput = {
    create?: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput> | AppointmentCreateWithoutAvailabilityInput[] | AppointmentUncheckedCreateWithoutAvailabilityInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAvailabilityInput | AppointmentCreateOrConnectWithoutAvailabilityInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAvailabilityInput | AppointmentUpsertWithWhereUniqueWithoutAvailabilityInput[]
    createMany?: AppointmentCreateManyAvailabilityInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAvailabilityInput | AppointmentUpdateWithWhereUniqueWithoutAvailabilityInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAvailabilityInput | AppointmentUpdateManyWithWhereWithoutAvailabilityInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ServiceProviderDetailsUpdateOneRequiredWithoutProvider_availabilityNestedInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_availabilityInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_availabilityInput
    upsert?: ServiceProviderDetailsUpsertWithoutProvider_availabilityInput
    connect?: ServiceProviderDetailsWhereUniqueInput
    update?: XOR<XOR<ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_availabilityInput, ServiceProviderDetailsUpdateWithoutProvider_availabilityInput>, ServiceProviderDetailsUncheckedUpdateWithoutProvider_availabilityInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutAvailabilityNestedInput = {
    create?: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput> | AppointmentCreateWithoutAvailabilityInput[] | AppointmentUncheckedCreateWithoutAvailabilityInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAvailabilityInput | AppointmentCreateOrConnectWithoutAvailabilityInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAvailabilityInput | AppointmentUpsertWithWhereUniqueWithoutAvailabilityInput[]
    createMany?: AppointmentCreateManyAvailabilityInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAvailabilityInput | AppointmentUpdateWithWhereUniqueWithoutAvailabilityInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAvailabilityInput | AppointmentUpdateManyWithWhereWithoutAvailabilityInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AvailabilityCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<AvailabilityCreateWithoutAppointmentsInput, AvailabilityUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AvailabilityCreateOrConnectWithoutAppointmentsInput
    connect?: AvailabilityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_appointmentsInput = {
    create?: XOR<UserCreateWithoutUser_appointmentsInput, UserUncheckedCreateWithoutUser_appointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_appointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_appointmentsInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_appointmentsInput
    connect?: ServiceProviderDetailsWhereUniqueInput
  }

  export type ServiceListingCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ServiceListingCreateWithoutAppointmentsInput, ServiceListingUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceListingCreateOrConnectWithoutAppointmentsInput
    connect?: ServiceListingWhereUniqueInput
  }

  export type RatingCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput> | RatingCreateWithoutAppointmentInput[] | RatingUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutAppointmentInput | RatingCreateOrConnectWithoutAppointmentInput[]
    createMany?: RatingCreateManyAppointmentInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput> | RatingCreateWithoutAppointmentInput[] | RatingUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutAppointmentInput | RatingCreateOrConnectWithoutAppointmentInput[]
    createMany?: RatingCreateManyAppointmentInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<AvailabilityCreateWithoutAppointmentsInput, AvailabilityUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: AvailabilityCreateOrConnectWithoutAppointmentsInput
    upsert?: AvailabilityUpsertWithoutAppointmentsInput
    connect?: AvailabilityWhereUniqueInput
    update?: XOR<XOR<AvailabilityUpdateToOneWithWhereWithoutAppointmentsInput, AvailabilityUpdateWithoutAppointmentsInput>, AvailabilityUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUser_appointmentsNestedInput = {
    create?: XOR<UserCreateWithoutUser_appointmentsInput, UserUncheckedCreateWithoutUser_appointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_appointmentsInput
    upsert?: UserUpsertWithoutUser_appointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_appointmentsInput, UserUpdateWithoutUser_appointmentsInput>, UserUncheckedUpdateWithoutUser_appointmentsInput>
  }

  export type ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_appointmentsInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_appointmentsInput
    upsert?: ServiceProviderDetailsUpsertWithoutProvider_appointmentsInput
    connect?: ServiceProviderDetailsWhereUniqueInput
    update?: XOR<XOR<ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_appointmentsInput, ServiceProviderDetailsUpdateWithoutProvider_appointmentsInput>, ServiceProviderDetailsUncheckedUpdateWithoutProvider_appointmentsInput>
  }

  export type ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ServiceListingCreateWithoutAppointmentsInput, ServiceListingUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceListingCreateOrConnectWithoutAppointmentsInput
    upsert?: ServiceListingUpsertWithoutAppointmentsInput
    connect?: ServiceListingWhereUniqueInput
    update?: XOR<XOR<ServiceListingUpdateToOneWithWhereWithoutAppointmentsInput, ServiceListingUpdateWithoutAppointmentsInput>, ServiceListingUncheckedUpdateWithoutAppointmentsInput>
  }

  export type RatingUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput> | RatingCreateWithoutAppointmentInput[] | RatingUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutAppointmentInput | RatingCreateOrConnectWithoutAppointmentInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutAppointmentInput | RatingUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: RatingCreateManyAppointmentInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutAppointmentInput | RatingUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutAppointmentInput | RatingUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput> | RatingCreateWithoutAppointmentInput[] | RatingUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutAppointmentInput | RatingCreateOrConnectWithoutAppointmentInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutAppointmentInput | RatingUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: RatingCreateManyAppointmentInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutAppointmentInput | RatingUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutAppointmentInput | RatingUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutAppointment_ratingInput = {
    create?: XOR<AppointmentCreateWithoutAppointment_ratingInput, AppointmentUncheckedCreateWithoutAppointment_ratingInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointment_ratingInput
    connect?: AppointmentWhereUniqueInput
  }

  export type ServiceProviderDetailsCreateNestedOneWithoutProvider_ratingsInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_ratingsInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_ratingsInput
    connect?: ServiceProviderDetailsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_ratingInput = {
    create?: XOR<UserCreateWithoutUser_ratingInput, UserUncheckedCreateWithoutUser_ratingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_ratingInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutAppointment_ratingNestedInput = {
    create?: XOR<AppointmentCreateWithoutAppointment_ratingInput, AppointmentUncheckedCreateWithoutAppointment_ratingInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointment_ratingInput
    upsert?: AppointmentUpsertWithoutAppointment_ratingInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutAppointment_ratingInput, AppointmentUpdateWithoutAppointment_ratingInput>, AppointmentUncheckedUpdateWithoutAppointment_ratingInput>
  }

  export type ServiceProviderDetailsUpdateOneRequiredWithoutProvider_ratingsNestedInput = {
    create?: XOR<ServiceProviderDetailsCreateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_ratingsInput>
    connectOrCreate?: ServiceProviderDetailsCreateOrConnectWithoutProvider_ratingsInput
    upsert?: ServiceProviderDetailsUpsertWithoutProvider_ratingsInput
    connect?: ServiceProviderDetailsWhereUniqueInput
    update?: XOR<XOR<ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_ratingsInput, ServiceProviderDetailsUpdateWithoutProvider_ratingsInput>, ServiceProviderDetailsUncheckedUpdateWithoutProvider_ratingsInput>
  }

  export type UserUpdateOneRequiredWithoutUser_ratingNestedInput = {
    create?: XOR<UserCreateWithoutUser_ratingInput, UserUncheckedCreateWithoutUser_ratingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_ratingInput
    upsert?: UserUpsertWithoutUser_ratingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_ratingInput, UserUpdateWithoutUser_ratingInput>, UserUncheckedUpdateWithoutUser_ratingInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AppointmentCreateWithoutCustomerInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    availability: AvailabilityCreateNestedOneWithoutAppointmentsInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput
    service: ServiceListingCreateNestedOneWithoutAppointmentsInput
    appointment_rating?: RatingCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutCustomerInput = {
    appointment_id?: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
    appointment_rating?: RatingUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type AppointmentCreateManyCustomerInputEnvelope = {
    data: AppointmentCreateManyCustomerInput | AppointmentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutUserInput = {
    rating_value: number
    rating_comment?: string | null
    rated_by: string
    created_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutAppointment_ratingInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_ratingsInput
  }

  export type RatingUncheckedCreateWithoutUserInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingCreateOrConnectWithoutUserInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingCreateManyUserInputEnvelope = {
    data: RatingCreateManyUserInput | RatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutCustomerInput, AppointmentUncheckedUpdateWithoutCustomerInput>
    create: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutCustomerInput, AppointmentUncheckedUpdateWithoutCustomerInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutCustomerInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    appointment_id?: IntFilter<"Appointment"> | number
    customer_id?: IntFilter<"Appointment"> | number
    provider_id?: IntFilter<"Appointment"> | number
    appointment_status?: StringFilter<"Appointment"> | string
    scheduled_date?: DateTimeFilter<"Appointment"> | Date | string
    repairDescription?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    final_price?: FloatNullableFilter<"Appointment"> | number | null
    availability_id?: IntFilter<"Appointment"> | number
    service_id?: IntFilter<"Appointment"> | number
    cancellation_reason?: StringNullableFilter<"Appointment"> | string | null
  }

  export type RatingUpsertWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
  }

  export type RatingUpdateManyWithWhereWithoutUserInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutUserInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: IntFilter<"Rating"> | number
    rating_value?: IntFilter<"Rating"> | number
    rating_comment?: StringNullableFilter<"Rating"> | string | null
    appointment_id?: IntFilter<"Rating"> | number
    user_id?: IntFilter<"Rating"> | number
    provider_id?: IntFilter<"Rating"> | number
    rated_by?: StringFilter<"Rating"> | string
    created_at?: DateTimeFilter<"Rating"> | Date | string
  }

  export type AppointmentCreateWithoutServiceProviderInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    availability: AvailabilityCreateNestedOneWithoutAppointmentsInput
    customer: UserCreateNestedOneWithoutUser_appointmentsInput
    service: ServiceListingCreateNestedOneWithoutAppointmentsInput
    appointment_rating?: RatingCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutServiceProviderInput = {
    appointment_id?: number
    customer_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
    appointment_rating?: RatingUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentCreateManyServiceProviderInputEnvelope = {
    data: AppointmentCreateManyServiceProviderInput | AppointmentCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityCreateWithoutServiceProviderInput = {
    dayOfWeek: string
    startTime: string
    endTime: string
    availability_isActive?: boolean
    appointments?: AppointmentCreateNestedManyWithoutAvailabilityInput
  }

  export type AvailabilityUncheckedCreateWithoutServiceProviderInput = {
    availability_id?: number
    dayOfWeek: string
    startTime: string
    endTime: string
    availability_isActive?: boolean
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAvailabilityInput
  }

  export type AvailabilityCreateOrConnectWithoutServiceProviderInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput>
  }

  export type AvailabilityCreateManyServiceProviderInputEnvelope = {
    data: AvailabilityCreateManyServiceProviderInput | AvailabilityCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutProviderInput = {
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
    CoveredService?: CoveredServiceCreateNestedManyWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutProviderInput = {
    certificate_id?: number
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
    CoveredService?: CoveredServiceUncheckedCreateNestedManyWithoutCertificateInput
  }

  export type CertificateCreateOrConnectWithoutProviderInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput>
  }

  export type CertificateCreateManyProviderInputEnvelope = {
    data: CertificateCreateManyProviderInput | CertificateCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutServiceProviderInput = {
    rating_value: number
    rating_comment?: string | null
    rated_by: string
    created_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutAppointment_ratingInput
    user: UserCreateNestedOneWithoutUser_ratingInput
  }

  export type RatingUncheckedCreateWithoutServiceProviderInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    user_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingCreateOrConnectWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput>
  }

  export type RatingCreateManyServiceProviderInputEnvelope = {
    data: RatingCreateManyServiceProviderInput | RatingCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceListingCreateWithoutServiceProviderInput = {
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    specific_services?: SpecificServiceCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingUncheckedCreateWithoutServiceProviderInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
    specific_services?: SpecificServiceUncheckedCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingCreateOrConnectWithoutServiceProviderInput = {
    where: ServiceListingWhereUniqueInput
    create: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput>
  }

  export type ServiceListingCreateManyServiceProviderInputEnvelope = {
    data: ServiceListingCreateManyServiceProviderInput | ServiceListingCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AppointmentCreateWithoutServiceProviderInput, AppointmentUncheckedCreateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceProviderInput, AppointmentUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutServiceProviderInput, AvailabilityUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<AvailabilityCreateWithoutServiceProviderInput, AvailabilityUncheckedCreateWithoutServiceProviderInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutServiceProviderInput, AvailabilityUncheckedUpdateWithoutServiceProviderInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutServiceProviderInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    availability_id?: IntFilter<"Availability"> | number
    dayOfWeek?: StringFilter<"Availability"> | string
    startTime?: StringFilter<"Availability"> | string
    endTime?: StringFilter<"Availability"> | string
    provider_id?: IntFilter<"Availability"> | number
    availability_isActive?: BoolFilter<"Availability"> | boolean
  }

  export type CertificateUpsertWithWhereUniqueWithoutProviderInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutProviderInput, CertificateUncheckedUpdateWithoutProviderInput>
    create: XOR<CertificateCreateWithoutProviderInput, CertificateUncheckedCreateWithoutProviderInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutProviderInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutProviderInput, CertificateUncheckedUpdateWithoutProviderInput>
  }

  export type CertificateUpdateManyWithWhereWithoutProviderInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutProviderInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    certificate_id?: IntFilter<"Certificate"> | number
    certificate_name?: StringFilter<"Certificate"> | string
    certificate_file_path?: StringFilter<"Certificate"> | string
    expiry_date?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    provider_id?: IntFilter<"Certificate"> | number
    certificate_number?: StringFilter<"Certificate"> | string
    certificate_status?: StringFilter<"Certificate"> | string
    created_at?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutServiceProviderInput, RatingUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<RatingCreateWithoutServiceProviderInput, RatingUncheckedCreateWithoutServiceProviderInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutServiceProviderInput, RatingUncheckedUpdateWithoutServiceProviderInput>
  }

  export type RatingUpdateManyWithWhereWithoutServiceProviderInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type ServiceListingUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: ServiceListingWhereUniqueInput
    update: XOR<ServiceListingUpdateWithoutServiceProviderInput, ServiceListingUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<ServiceListingCreateWithoutServiceProviderInput, ServiceListingUncheckedCreateWithoutServiceProviderInput>
  }

  export type ServiceListingUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: ServiceListingWhereUniqueInput
    data: XOR<ServiceListingUpdateWithoutServiceProviderInput, ServiceListingUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceListingUpdateManyWithWhereWithoutServiceProviderInput = {
    where: ServiceListingScalarWhereInput
    data: XOR<ServiceListingUpdateManyMutationInput, ServiceListingUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type ServiceListingScalarWhereInput = {
    AND?: ServiceListingScalarWhereInput | ServiceListingScalarWhereInput[]
    OR?: ServiceListingScalarWhereInput[]
    NOT?: ServiceListingScalarWhereInput | ServiceListingScalarWhereInput[]
    service_id?: IntFilter<"ServiceListing"> | number
    service_title?: StringFilter<"ServiceListing"> | string
    service_description?: StringFilter<"ServiceListing"> | string
    service_startingprice?: FloatFilter<"ServiceListing"> | number
    provider_id?: IntFilter<"ServiceListing"> | number
    servicelisting_isActive?: BoolFilter<"ServiceListing"> | boolean
    service_picture?: StringNullableFilter<"ServiceListing"> | string | null
  }

  export type ServiceProviderDetailsCreateWithoutProvider_certificatesInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityCreateNestedManyWithoutServiceProviderInput
    provider_ratings?: RatingCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateWithoutProvider_certificatesInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_ratings?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsCreateOrConnectWithoutProvider_certificatesInput = {
    where: ServiceProviderDetailsWhereUniqueInput
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_certificatesInput>
  }

  export type CoveredServiceCreateWithoutCertificateInput = {
    specific_service: SpecificServiceCreateNestedOneWithoutCovered_by_certificatesInput
  }

  export type CoveredServiceUncheckedCreateWithoutCertificateInput = {
    covered_service_id?: number
    specific_service_id: number
  }

  export type CoveredServiceCreateOrConnectWithoutCertificateInput = {
    where: CoveredServiceWhereUniqueInput
    create: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput>
  }

  export type CoveredServiceCreateManyCertificateInputEnvelope = {
    data: CoveredServiceCreateManyCertificateInput | CoveredServiceCreateManyCertificateInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderDetailsUpsertWithoutProvider_certificatesInput = {
    update: XOR<ServiceProviderDetailsUpdateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_certificatesInput>
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_certificatesInput>
    where?: ServiceProviderDetailsWhereInput
  }

  export type ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_certificatesInput = {
    where?: ServiceProviderDetailsWhereInput
    data: XOR<ServiceProviderDetailsUpdateWithoutProvider_certificatesInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_certificatesInput>
  }

  export type ServiceProviderDetailsUpdateWithoutProvider_certificatesInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUpdateManyWithoutServiceProviderNestedInput
    provider_ratings?: RatingUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateWithoutProvider_certificatesInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_ratings?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type CoveredServiceUpsertWithWhereUniqueWithoutCertificateInput = {
    where: CoveredServiceWhereUniqueInput
    update: XOR<CoveredServiceUpdateWithoutCertificateInput, CoveredServiceUncheckedUpdateWithoutCertificateInput>
    create: XOR<CoveredServiceCreateWithoutCertificateInput, CoveredServiceUncheckedCreateWithoutCertificateInput>
  }

  export type CoveredServiceUpdateWithWhereUniqueWithoutCertificateInput = {
    where: CoveredServiceWhereUniqueInput
    data: XOR<CoveredServiceUpdateWithoutCertificateInput, CoveredServiceUncheckedUpdateWithoutCertificateInput>
  }

  export type CoveredServiceUpdateManyWithWhereWithoutCertificateInput = {
    where: CoveredServiceScalarWhereInput
    data: XOR<CoveredServiceUpdateManyMutationInput, CoveredServiceUncheckedUpdateManyWithoutCertificateInput>
  }

  export type CoveredServiceScalarWhereInput = {
    AND?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
    OR?: CoveredServiceScalarWhereInput[]
    NOT?: CoveredServiceScalarWhereInput | CoveredServiceScalarWhereInput[]
    covered_service_id?: IntFilter<"CoveredService"> | number
    specific_service_id?: IntFilter<"CoveredService"> | number
    certificate_id?: IntFilter<"CoveredService"> | number
  }

  export type AppointmentCreateWithoutServiceInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    availability: AvailabilityCreateNestedOneWithoutAppointmentsInput
    customer: UserCreateNestedOneWithoutUser_appointmentsInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput
    appointment_rating?: RatingCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutServiceInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    cancellation_reason?: string | null
    appointment_rating?: RatingUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentCreateManyServiceInputEnvelope = {
    data: AppointmentCreateManyServiceInput | AppointmentCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderDetailsCreateWithoutProvider_servicesInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateWithoutProvider_servicesInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateUncheckedCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsCreateOrConnectWithoutProvider_servicesInput = {
    where: ServiceProviderDetailsWhereUniqueInput
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_servicesInput>
  }

  export type SpecificServiceCreateWithoutServiceListingInput = {
    specific_service_title: string
    specific_service_description: string
    covered_by_certificates?: CoveredServiceCreateNestedManyWithoutSpecific_serviceInput
    category: ServiceCategoryCreateNestedOneWithoutSpecific_servicesInput
  }

  export type SpecificServiceUncheckedCreateWithoutServiceListingInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    category_id: number
    covered_by_certificates?: CoveredServiceUncheckedCreateNestedManyWithoutSpecific_serviceInput
  }

  export type SpecificServiceCreateOrConnectWithoutServiceListingInput = {
    where: SpecificServiceWhereUniqueInput
    create: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput>
  }

  export type SpecificServiceCreateManyServiceListingInputEnvelope = {
    data: SpecificServiceCreateManyServiceListingInput | SpecificServiceCreateManyServiceListingInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceProviderDetailsUpsertWithoutProvider_servicesInput = {
    update: XOR<ServiceProviderDetailsUpdateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_servicesInput>
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_servicesInput>
    where?: ServiceProviderDetailsWhereInput
  }

  export type ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_servicesInput = {
    where?: ServiceProviderDetailsWhereInput
    data: XOR<ServiceProviderDetailsUpdateWithoutProvider_servicesInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_servicesInput>
  }

  export type ServiceProviderDetailsUpdateWithoutProvider_servicesInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateWithoutProvider_servicesInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUncheckedUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type SpecificServiceUpsertWithWhereUniqueWithoutServiceListingInput = {
    where: SpecificServiceWhereUniqueInput
    update: XOR<SpecificServiceUpdateWithoutServiceListingInput, SpecificServiceUncheckedUpdateWithoutServiceListingInput>
    create: XOR<SpecificServiceCreateWithoutServiceListingInput, SpecificServiceUncheckedCreateWithoutServiceListingInput>
  }

  export type SpecificServiceUpdateWithWhereUniqueWithoutServiceListingInput = {
    where: SpecificServiceWhereUniqueInput
    data: XOR<SpecificServiceUpdateWithoutServiceListingInput, SpecificServiceUncheckedUpdateWithoutServiceListingInput>
  }

  export type SpecificServiceUpdateManyWithWhereWithoutServiceListingInput = {
    where: SpecificServiceScalarWhereInput
    data: XOR<SpecificServiceUpdateManyMutationInput, SpecificServiceUncheckedUpdateManyWithoutServiceListingInput>
  }

  export type SpecificServiceScalarWhereInput = {
    AND?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
    OR?: SpecificServiceScalarWhereInput[]
    NOT?: SpecificServiceScalarWhereInput | SpecificServiceScalarWhereInput[]
    specific_service_id?: IntFilter<"SpecificService"> | number
    specific_service_title?: StringFilter<"SpecificService"> | string
    specific_service_description?: StringFilter<"SpecificService"> | string
    service_id?: IntFilter<"SpecificService"> | number
    category_id?: IntFilter<"SpecificService"> | number
  }

  export type SpecificServiceCreateWithoutCategoryInput = {
    specific_service_title: string
    specific_service_description: string
    covered_by_certificates?: CoveredServiceCreateNestedManyWithoutSpecific_serviceInput
    serviceListing: ServiceListingCreateNestedOneWithoutSpecific_servicesInput
  }

  export type SpecificServiceUncheckedCreateWithoutCategoryInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
    covered_by_certificates?: CoveredServiceUncheckedCreateNestedManyWithoutSpecific_serviceInput
  }

  export type SpecificServiceCreateOrConnectWithoutCategoryInput = {
    where: SpecificServiceWhereUniqueInput
    create: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput>
  }

  export type SpecificServiceCreateManyCategoryInputEnvelope = {
    data: SpecificServiceCreateManyCategoryInput | SpecificServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SpecificServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SpecificServiceWhereUniqueInput
    update: XOR<SpecificServiceUpdateWithoutCategoryInput, SpecificServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<SpecificServiceCreateWithoutCategoryInput, SpecificServiceUncheckedCreateWithoutCategoryInput>
  }

  export type SpecificServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SpecificServiceWhereUniqueInput
    data: XOR<SpecificServiceUpdateWithoutCategoryInput, SpecificServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type SpecificServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: SpecificServiceScalarWhereInput
    data: XOR<SpecificServiceUpdateManyMutationInput, SpecificServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CoveredServiceCreateWithoutSpecific_serviceInput = {
    certificate: CertificateCreateNestedOneWithoutCoveredServiceInput
  }

  export type CoveredServiceUncheckedCreateWithoutSpecific_serviceInput = {
    covered_service_id?: number
    certificate_id: number
  }

  export type CoveredServiceCreateOrConnectWithoutSpecific_serviceInput = {
    where: CoveredServiceWhereUniqueInput
    create: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput>
  }

  export type CoveredServiceCreateManySpecific_serviceInputEnvelope = {
    data: CoveredServiceCreateManySpecific_serviceInput | CoveredServiceCreateManySpecific_serviceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryCreateWithoutSpecific_servicesInput = {
    category_name: string
  }

  export type ServiceCategoryUncheckedCreateWithoutSpecific_servicesInput = {
    category_id?: number
    category_name: string
  }

  export type ServiceCategoryCreateOrConnectWithoutSpecific_servicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutSpecific_servicesInput, ServiceCategoryUncheckedCreateWithoutSpecific_servicesInput>
  }

  export type ServiceListingCreateWithoutSpecific_servicesInput = {
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_servicesInput
  }

  export type ServiceListingUncheckedCreateWithoutSpecific_servicesInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    provider_id: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceListingCreateOrConnectWithoutSpecific_servicesInput = {
    where: ServiceListingWhereUniqueInput
    create: XOR<ServiceListingCreateWithoutSpecific_servicesInput, ServiceListingUncheckedCreateWithoutSpecific_servicesInput>
  }

  export type CoveredServiceUpsertWithWhereUniqueWithoutSpecific_serviceInput = {
    where: CoveredServiceWhereUniqueInput
    update: XOR<CoveredServiceUpdateWithoutSpecific_serviceInput, CoveredServiceUncheckedUpdateWithoutSpecific_serviceInput>
    create: XOR<CoveredServiceCreateWithoutSpecific_serviceInput, CoveredServiceUncheckedCreateWithoutSpecific_serviceInput>
  }

  export type CoveredServiceUpdateWithWhereUniqueWithoutSpecific_serviceInput = {
    where: CoveredServiceWhereUniqueInput
    data: XOR<CoveredServiceUpdateWithoutSpecific_serviceInput, CoveredServiceUncheckedUpdateWithoutSpecific_serviceInput>
  }

  export type CoveredServiceUpdateManyWithWhereWithoutSpecific_serviceInput = {
    where: CoveredServiceScalarWhereInput
    data: XOR<CoveredServiceUpdateManyMutationInput, CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceInput>
  }

  export type ServiceCategoryUpsertWithoutSpecific_servicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutSpecific_servicesInput, ServiceCategoryUncheckedUpdateWithoutSpecific_servicesInput>
    create: XOR<ServiceCategoryCreateWithoutSpecific_servicesInput, ServiceCategoryUncheckedCreateWithoutSpecific_servicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutSpecific_servicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutSpecific_servicesInput, ServiceCategoryUncheckedUpdateWithoutSpecific_servicesInput>
  }

  export type ServiceCategoryUpdateWithoutSpecific_servicesInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryUncheckedUpdateWithoutSpecific_servicesInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceListingUpsertWithoutSpecific_servicesInput = {
    update: XOR<ServiceListingUpdateWithoutSpecific_servicesInput, ServiceListingUncheckedUpdateWithoutSpecific_servicesInput>
    create: XOR<ServiceListingCreateWithoutSpecific_servicesInput, ServiceListingUncheckedCreateWithoutSpecific_servicesInput>
    where?: ServiceListingWhereInput
  }

  export type ServiceListingUpdateToOneWithWhereWithoutSpecific_servicesInput = {
    where?: ServiceListingWhereInput
    data: XOR<ServiceListingUpdateWithoutSpecific_servicesInput, ServiceListingUncheckedUpdateWithoutSpecific_servicesInput>
  }

  export type ServiceListingUpdateWithoutSpecific_servicesInput = {
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_servicesNestedInput
  }

  export type ServiceListingUncheckedUpdateWithoutSpecific_servicesInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CertificateCreateWithoutCoveredServiceInput = {
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
    provider: ServiceProviderDetailsCreateNestedOneWithoutProvider_certificatesInput
  }

  export type CertificateUncheckedCreateWithoutCoveredServiceInput = {
    certificate_id?: number
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    provider_id: number
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
  }

  export type CertificateCreateOrConnectWithoutCoveredServiceInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCoveredServiceInput, CertificateUncheckedCreateWithoutCoveredServiceInput>
  }

  export type SpecificServiceCreateWithoutCovered_by_certificatesInput = {
    specific_service_title: string
    specific_service_description: string
    category: ServiceCategoryCreateNestedOneWithoutSpecific_servicesInput
    serviceListing: ServiceListingCreateNestedOneWithoutSpecific_servicesInput
  }

  export type SpecificServiceUncheckedCreateWithoutCovered_by_certificatesInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
    category_id: number
  }

  export type SpecificServiceCreateOrConnectWithoutCovered_by_certificatesInput = {
    where: SpecificServiceWhereUniqueInput
    create: XOR<SpecificServiceCreateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedCreateWithoutCovered_by_certificatesInput>
  }

  export type CertificateUpsertWithoutCoveredServiceInput = {
    update: XOR<CertificateUpdateWithoutCoveredServiceInput, CertificateUncheckedUpdateWithoutCoveredServiceInput>
    create: XOR<CertificateCreateWithoutCoveredServiceInput, CertificateUncheckedCreateWithoutCoveredServiceInput>
    where?: CertificateWhereInput
  }

  export type CertificateUpdateToOneWithWhereWithoutCoveredServiceInput = {
    where?: CertificateWhereInput
    data: XOR<CertificateUpdateWithoutCoveredServiceInput, CertificateUncheckedUpdateWithoutCoveredServiceInput>
  }

  export type CertificateUpdateWithoutCoveredServiceInput = {
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_certificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCoveredServiceInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_id?: IntFieldUpdateOperationsInput | number
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecificServiceUpsertWithoutCovered_by_certificatesInput = {
    update: XOR<SpecificServiceUpdateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedUpdateWithoutCovered_by_certificatesInput>
    create: XOR<SpecificServiceCreateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedCreateWithoutCovered_by_certificatesInput>
    where?: SpecificServiceWhereInput
  }

  export type SpecificServiceUpdateToOneWithWhereWithoutCovered_by_certificatesInput = {
    where?: SpecificServiceWhereInput
    data: XOR<SpecificServiceUpdateWithoutCovered_by_certificatesInput, SpecificServiceUncheckedUpdateWithoutCovered_by_certificatesInput>
  }

  export type SpecificServiceUpdateWithoutCovered_by_certificatesInput = {
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    category?: ServiceCategoryUpdateOneRequiredWithoutSpecific_servicesNestedInput
    serviceListing?: ServiceListingUpdateOneRequiredWithoutSpecific_servicesNestedInput
  }

  export type SpecificServiceUncheckedUpdateWithoutCovered_by_certificatesInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentCreateWithoutAvailabilityInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    customer: UserCreateNestedOneWithoutUser_appointmentsInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput
    service: ServiceListingCreateNestedOneWithoutAppointmentsInput
    appointment_rating?: RatingCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutAvailabilityInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    service_id: number
    cancellation_reason?: string | null
    appointment_rating?: RatingUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutAvailabilityInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput>
  }

  export type AppointmentCreateManyAvailabilityInputEnvelope = {
    data: AppointmentCreateManyAvailabilityInput | AppointmentCreateManyAvailabilityInput[]
    skipDuplicates?: boolean
  }

  export type ServiceProviderDetailsCreateWithoutProvider_availabilityInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateWithoutProvider_availabilityInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateUncheckedCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsCreateOrConnectWithoutProvider_availabilityInput = {
    where: ServiceProviderDetailsWhereUniqueInput
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_availabilityInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutAvailabilityInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutAvailabilityInput, AppointmentUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<AppointmentCreateWithoutAvailabilityInput, AppointmentUncheckedCreateWithoutAvailabilityInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutAvailabilityInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutAvailabilityInput, AppointmentUncheckedUpdateWithoutAvailabilityInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutAvailabilityInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAvailabilityInput>
  }

  export type ServiceProviderDetailsUpsertWithoutProvider_availabilityInput = {
    update: XOR<ServiceProviderDetailsUpdateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_availabilityInput>
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_availabilityInput>
    where?: ServiceProviderDetailsWhereInput
  }

  export type ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_availabilityInput = {
    where?: ServiceProviderDetailsWhereInput
    data: XOR<ServiceProviderDetailsUpdateWithoutProvider_availabilityInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_availabilityInput>
  }

  export type ServiceProviderDetailsUpdateWithoutProvider_availabilityInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateWithoutProvider_availabilityInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUncheckedUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type AvailabilityCreateWithoutAppointmentsInput = {
    dayOfWeek: string
    startTime: string
    endTime: string
    availability_isActive?: boolean
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_availabilityInput
  }

  export type AvailabilityUncheckedCreateWithoutAppointmentsInput = {
    availability_id?: number
    dayOfWeek: string
    startTime: string
    endTime: string
    provider_id: number
    availability_isActive?: boolean
  }

  export type AvailabilityCreateOrConnectWithoutAppointmentsInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutAppointmentsInput, AvailabilityUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutUser_appointmentsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_rating?: RatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_appointmentsInput = {
    user_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_rating?: RatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_appointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_appointmentsInput, UserUncheckedCreateWithoutUser_appointmentsInput>
  }

  export type ServiceProviderDetailsCreateWithoutProvider_appointmentsInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_availability?: AvailabilityCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateWithoutProvider_appointmentsInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_availability?: AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateUncheckedCreateNestedManyWithoutProviderInput
    provider_ratings?: RatingUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_services?: ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsCreateOrConnectWithoutProvider_appointmentsInput = {
    where: ServiceProviderDetailsWhereUniqueInput
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_appointmentsInput>
  }

  export type ServiceListingCreateWithoutAppointmentsInput = {
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_servicesInput
    specific_services?: SpecificServiceCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingUncheckedCreateWithoutAppointmentsInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    provider_id: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
    specific_services?: SpecificServiceUncheckedCreateNestedManyWithoutServiceListingInput
  }

  export type ServiceListingCreateOrConnectWithoutAppointmentsInput = {
    where: ServiceListingWhereUniqueInput
    create: XOR<ServiceListingCreateWithoutAppointmentsInput, ServiceListingUncheckedCreateWithoutAppointmentsInput>
  }

  export type RatingCreateWithoutAppointmentInput = {
    rating_value: number
    rating_comment?: string | null
    rated_by: string
    created_at?: Date | string
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_ratingsInput
    user: UserCreateNestedOneWithoutUser_ratingInput
  }

  export type RatingUncheckedCreateWithoutAppointmentInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    user_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingCreateOrConnectWithoutAppointmentInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput>
  }

  export type RatingCreateManyAppointmentInputEnvelope = {
    data: RatingCreateManyAppointmentInput | RatingCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityUpsertWithoutAppointmentsInput = {
    update: XOR<AvailabilityUpdateWithoutAppointmentsInput, AvailabilityUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<AvailabilityCreateWithoutAppointmentsInput, AvailabilityUncheckedCreateWithoutAppointmentsInput>
    where?: AvailabilityWhereInput
  }

  export type AvailabilityUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: AvailabilityWhereInput
    data: XOR<AvailabilityUpdateWithoutAppointmentsInput, AvailabilityUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AvailabilityUpdateWithoutAppointmentsInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_availabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateWithoutAppointmentsInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    provider_id?: IntFieldUpdateOperationsInput | number
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutUser_appointmentsInput = {
    update: XOR<UserUpdateWithoutUser_appointmentsInput, UserUncheckedUpdateWithoutUser_appointmentsInput>
    create: XOR<UserCreateWithoutUser_appointmentsInput, UserUncheckedCreateWithoutUser_appointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_appointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_appointmentsInput, UserUncheckedUpdateWithoutUser_appointmentsInput>
  }

  export type UserUpdateWithoutUser_appointmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_rating?: RatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_appointmentsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_rating?: RatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceProviderDetailsUpsertWithoutProvider_appointmentsInput = {
    update: XOR<ServiceProviderDetailsUpdateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_appointmentsInput>
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_appointmentsInput>
    where?: ServiceProviderDetailsWhereInput
  }

  export type ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_appointmentsInput = {
    where?: ServiceProviderDetailsWhereInput
    data: XOR<ServiceProviderDetailsUpdateWithoutProvider_appointmentsInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_appointmentsInput>
  }

  export type ServiceProviderDetailsUpdateWithoutProvider_appointmentsInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_availability?: AvailabilityUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateWithoutProvider_appointmentsInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_availability?: AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUncheckedUpdateManyWithoutProviderNestedInput
    provider_ratings?: RatingUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_services?: ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceListingUpsertWithoutAppointmentsInput = {
    update: XOR<ServiceListingUpdateWithoutAppointmentsInput, ServiceListingUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ServiceListingCreateWithoutAppointmentsInput, ServiceListingUncheckedCreateWithoutAppointmentsInput>
    where?: ServiceListingWhereInput
  }

  export type ServiceListingUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ServiceListingWhereInput
    data: XOR<ServiceListingUpdateWithoutAppointmentsInput, ServiceListingUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceListingUpdateWithoutAppointmentsInput = {
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_servicesNestedInput
    specific_services?: SpecificServiceUpdateManyWithoutServiceListingNestedInput
  }

  export type ServiceListingUncheckedUpdateWithoutAppointmentsInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    specific_services?: SpecificServiceUncheckedUpdateManyWithoutServiceListingNestedInput
  }

  export type RatingUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutAppointmentInput, RatingUncheckedUpdateWithoutAppointmentInput>
    create: XOR<RatingCreateWithoutAppointmentInput, RatingUncheckedCreateWithoutAppointmentInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutAppointmentInput, RatingUncheckedUpdateWithoutAppointmentInput>
  }

  export type RatingUpdateManyWithWhereWithoutAppointmentInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentCreateWithoutAppointment_ratingInput = {
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    cancellation_reason?: string | null
    availability: AvailabilityCreateNestedOneWithoutAppointmentsInput
    customer: UserCreateNestedOneWithoutUser_appointmentsInput
    serviceProvider: ServiceProviderDetailsCreateNestedOneWithoutProvider_appointmentsInput
    service: ServiceListingCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutAppointment_ratingInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
  }

  export type AppointmentCreateOrConnectWithoutAppointment_ratingInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAppointment_ratingInput, AppointmentUncheckedCreateWithoutAppointment_ratingInput>
  }

  export type ServiceProviderDetailsCreateWithoutProvider_ratingsInput = {
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateCreateNestedManyWithoutProviderInput
    provider_services?: ServiceListingCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsUncheckedCreateWithoutProvider_ratingsInput = {
    provider_id?: number
    provider_first_name: string
    provider_last_name: string
    provider_email: string
    provider_phone_number: string
    provider_profile_photo?: string | null
    provider_valid_id?: string | null
    provider_isVerified?: boolean
    created_at?: Date | string
    provider_rating?: number
    provider_location?: string | null
    provider_uli: string
    provider_password: string
    provider_userName: string
    provider_isActivated?: boolean
    provider_birthday?: Date | string | null
    provider_exact_location?: string | null
    provider_appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_availability?: AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput
    provider_certificates?: CertificateUncheckedCreateNestedManyWithoutProviderInput
    provider_services?: ServiceListingUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderDetailsCreateOrConnectWithoutProvider_ratingsInput = {
    where: ServiceProviderDetailsWhereUniqueInput
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_ratingsInput>
  }

  export type UserCreateWithoutUser_ratingInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_appointments?: AppointmentCreateNestedManyWithoutCustomerInput
  }

  export type UserUncheckedCreateWithoutUser_ratingInput = {
    user_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    profile_photo?: string | null
    valid_id?: string | null
    user_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    password: string
    userName: string
    is_activated?: boolean
    birthday?: Date | string | null
    exact_location?: string | null
    user_appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCreateOrConnectWithoutUser_ratingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_ratingInput, UserUncheckedCreateWithoutUser_ratingInput>
  }

  export type AppointmentUpsertWithoutAppointment_ratingInput = {
    update: XOR<AppointmentUpdateWithoutAppointment_ratingInput, AppointmentUncheckedUpdateWithoutAppointment_ratingInput>
    create: XOR<AppointmentCreateWithoutAppointment_ratingInput, AppointmentUncheckedCreateWithoutAppointment_ratingInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutAppointment_ratingInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutAppointment_ratingInput, AppointmentUncheckedUpdateWithoutAppointment_ratingInput>
  }

  export type AppointmentUpdateWithoutAppointment_ratingInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput
    customer?: UserUpdateOneRequiredWithoutUser_appointmentsNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput
    service?: ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAppointment_ratingInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProviderDetailsUpsertWithoutProvider_ratingsInput = {
    update: XOR<ServiceProviderDetailsUpdateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_ratingsInput>
    create: XOR<ServiceProviderDetailsCreateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedCreateWithoutProvider_ratingsInput>
    where?: ServiceProviderDetailsWhereInput
  }

  export type ServiceProviderDetailsUpdateToOneWithWhereWithoutProvider_ratingsInput = {
    where?: ServiceProviderDetailsWhereInput
    data: XOR<ServiceProviderDetailsUpdateWithoutProvider_ratingsInput, ServiceProviderDetailsUncheckedUpdateWithoutProvider_ratingsInput>
  }

  export type ServiceProviderDetailsUpdateWithoutProvider_ratingsInput = {
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUpdateManyWithoutProviderNestedInput
    provider_services?: ServiceListingUpdateManyWithoutServiceProviderNestedInput
  }

  export type ServiceProviderDetailsUncheckedUpdateWithoutProvider_ratingsInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_first_name?: StringFieldUpdateOperationsInput | string
    provider_last_name?: StringFieldUpdateOperationsInput | string
    provider_email?: StringFieldUpdateOperationsInput | string
    provider_phone_number?: StringFieldUpdateOperationsInput | string
    provider_profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    provider_valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_rating?: FloatFieldUpdateOperationsInput | number
    provider_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_uli?: StringFieldUpdateOperationsInput | string
    provider_password?: StringFieldUpdateOperationsInput | string
    provider_userName?: StringFieldUpdateOperationsInput | string
    provider_isActivated?: BoolFieldUpdateOperationsInput | boolean
    provider_birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    provider_appointments?: AppointmentUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_availability?: AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput
    provider_certificates?: CertificateUncheckedUpdateManyWithoutProviderNestedInput
    provider_services?: ServiceListingUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type UserUpsertWithoutUser_ratingInput = {
    update: XOR<UserUpdateWithoutUser_ratingInput, UserUncheckedUpdateWithoutUser_ratingInput>
    create: XOR<UserCreateWithoutUser_ratingInput, UserUncheckedCreateWithoutUser_ratingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_ratingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_ratingInput, UserUncheckedUpdateWithoutUser_ratingInput>
  }

  export type UserUpdateWithoutUser_ratingInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_ratingInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    valid_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    is_activated?: BoolFieldUpdateOperationsInput | boolean
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exact_location?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AppointmentCreateManyCustomerInput = {
    appointment_id?: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
  }

  export type RatingCreateManyUserInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type AppointmentUpdateWithoutCustomerInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput
    service?: ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput
    appointment_rating?: RatingUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCustomerInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_rating?: RatingUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutCustomerInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingUpdateWithoutUserInput = {
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutAppointment_ratingNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_ratingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyServiceProviderInput = {
    appointment_id?: number
    customer_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    service_id: number
    cancellation_reason?: string | null
  }

  export type AvailabilityCreateManyServiceProviderInput = {
    availability_id?: number
    dayOfWeek: string
    startTime: string
    endTime: string
    availability_isActive?: boolean
  }

  export type CertificateCreateManyProviderInput = {
    certificate_id?: number
    certificate_name: string
    certificate_file_path: string
    expiry_date?: Date | string | null
    certificate_number: string
    certificate_status?: string
    created_at?: Date | string
  }

  export type RatingCreateManyServiceProviderInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    appointment_id: number
    user_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type ServiceListingCreateManyServiceProviderInput = {
    service_id?: number
    service_title: string
    service_description: string
    service_startingprice: number
    servicelisting_isActive?: boolean
    service_picture?: string | null
  }

  export type AppointmentUpdateWithoutServiceProviderInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput
    customer?: UserUpdateOneRequiredWithoutUser_appointmentsNestedInput
    service?: ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput
    appointment_rating?: RatingUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceProviderInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_rating?: RatingUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceProviderInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailabilityUpdateWithoutServiceProviderInput = {
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
    appointments?: AppointmentUpdateManyWithoutAvailabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateWithoutServiceProviderInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
    appointments?: AppointmentUncheckedUpdateManyWithoutAvailabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateManyWithoutServiceProviderInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    availability_isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CertificateUpdateWithoutProviderInput = {
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    CoveredService?: CoveredServiceUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutProviderInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    CoveredService?: CoveredServiceUncheckedUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateManyWithoutProviderInput = {
    certificate_id?: IntFieldUpdateOperationsInput | number
    certificate_name?: StringFieldUpdateOperationsInput | string
    certificate_file_path?: StringFieldUpdateOperationsInput | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_number?: StringFieldUpdateOperationsInput | string
    certificate_status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutServiceProviderInput = {
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutAppointment_ratingNestedInput
    user?: UserUpdateOneRequiredWithoutUser_ratingNestedInput
  }

  export type RatingUncheckedUpdateWithoutServiceProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceListingUpdateWithoutServiceProviderInput = {
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
    specific_services?: SpecificServiceUpdateManyWithoutServiceListingNestedInput
  }

  export type ServiceListingUncheckedUpdateWithoutServiceProviderInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
    specific_services?: SpecificServiceUncheckedUpdateManyWithoutServiceListingNestedInput
  }

  export type ServiceListingUncheckedUpdateManyWithoutServiceProviderInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    service_title?: StringFieldUpdateOperationsInput | string
    service_description?: StringFieldUpdateOperationsInput | string
    service_startingprice?: FloatFieldUpdateOperationsInput | number
    servicelisting_isActive?: BoolFieldUpdateOperationsInput | boolean
    service_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoveredServiceCreateManyCertificateInput = {
    covered_service_id?: number
    specific_service_id: number
  }

  export type CoveredServiceUpdateWithoutCertificateInput = {
    specific_service?: SpecificServiceUpdateOneRequiredWithoutCovered_by_certificatesNestedInput
  }

  export type CoveredServiceUncheckedUpdateWithoutCertificateInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoveredServiceUncheckedUpdateManyWithoutCertificateInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_id?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentCreateManyServiceInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    availability_id: number
    cancellation_reason?: string | null
  }

  export type SpecificServiceCreateManyServiceListingInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    category_id: number
  }

  export type AppointmentUpdateWithoutServiceInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: AvailabilityUpdateOneRequiredWithoutAppointmentsNestedInput
    customer?: UserUpdateOneRequiredWithoutUser_appointmentsNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput
    appointment_rating?: RatingUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_rating?: RatingUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    availability_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificServiceUpdateWithoutServiceListingInput = {
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    covered_by_certificates?: CoveredServiceUpdateManyWithoutSpecific_serviceNestedInput
    category?: ServiceCategoryUpdateOneRequiredWithoutSpecific_servicesNestedInput
  }

  export type SpecificServiceUncheckedUpdateWithoutServiceListingInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    covered_by_certificates?: CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceNestedInput
  }

  export type SpecificServiceUncheckedUpdateManyWithoutServiceListingInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type SpecificServiceCreateManyCategoryInput = {
    specific_service_id?: number
    specific_service_title: string
    specific_service_description: string
    service_id: number
  }

  export type SpecificServiceUpdateWithoutCategoryInput = {
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    covered_by_certificates?: CoveredServiceUpdateManyWithoutSpecific_serviceNestedInput
    serviceListing?: ServiceListingUpdateOneRequiredWithoutSpecific_servicesNestedInput
  }

  export type SpecificServiceUncheckedUpdateWithoutCategoryInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    covered_by_certificates?: CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceNestedInput
  }

  export type SpecificServiceUncheckedUpdateManyWithoutCategoryInput = {
    specific_service_id?: IntFieldUpdateOperationsInput | number
    specific_service_title?: StringFieldUpdateOperationsInput | string
    specific_service_description?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoveredServiceCreateManySpecific_serviceInput = {
    covered_service_id?: number
    certificate_id: number
  }

  export type CoveredServiceUpdateWithoutSpecific_serviceInput = {
    certificate?: CertificateUpdateOneRequiredWithoutCoveredServiceNestedInput
  }

  export type CoveredServiceUncheckedUpdateWithoutSpecific_serviceInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoveredServiceUncheckedUpdateManyWithoutSpecific_serviceInput = {
    covered_service_id?: IntFieldUpdateOperationsInput | number
    certificate_id?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentCreateManyAvailabilityInput = {
    appointment_id?: number
    customer_id: number
    provider_id: number
    appointment_status: string
    scheduled_date: Date | string
    repairDescription?: string | null
    created_at?: Date | string
    final_price?: number | null
    service_id: number
    cancellation_reason?: string | null
  }

  export type AppointmentUpdateWithoutAvailabilityInput = {
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: UserUpdateOneRequiredWithoutUser_appointmentsNestedInput
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_appointmentsNestedInput
    service?: ServiceListingUpdateOneRequiredWithoutAppointmentsNestedInput
    appointment_rating?: RatingUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAvailabilityInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_rating?: RatingUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutAvailabilityInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    appointment_status?: StringFieldUpdateOperationsInput | string
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    repairDescription?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    final_price?: NullableFloatFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingCreateManyAppointmentInput = {
    id?: number
    rating_value: number
    rating_comment?: string | null
    user_id: number
    provider_id: number
    rated_by: string
    created_at?: Date | string
  }

  export type RatingUpdateWithoutAppointmentInput = {
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceProvider?: ServiceProviderDetailsUpdateOneRequiredWithoutProvider_ratingsNestedInput
    user?: UserUpdateOneRequiredWithoutUser_ratingNestedInput
  }

  export type RatingUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating_value?: IntFieldUpdateOperationsInput | number
    rating_comment?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    rated_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}